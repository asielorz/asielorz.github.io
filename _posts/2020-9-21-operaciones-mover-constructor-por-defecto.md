---
layout: post
title: 'Toda clase que especialice las operaciones de mover debería ser construible por defecto'
date: 2020-09-21
tags:
  programación
  c++
---
<p style='text-align: justify;'>La idea detrás del diseño de RAII es que los recursos pertenecen a objetos. Un recurso es todo aquello que hay que pedir a un sistema y devolver cuando se deje de usar. Por supuesto el sistema operativo maneja recursos, como la memoria o los archivos, pero también puede ser algo más abstracto como el tiempo de uso de un mutex, e incluso podemos diseñar nuestros propios recursos que abstraigan y representen el comportamiento de nuestros sistemas. Un objeto puede adquirir recursos en su constructor o a lo largo de su vida, y debe liberarlos en el destructor. En RAII hay tres operaciones esenciales: el destructor, que tiene como función liberar los recursos; la copia, que crea un objeto cuyo valor observable es igual al de otro; y mover, que transfiere los recursos de un objeto a otro, dejando al primero vacío.</p>

<p style='text-align: justify;'>El estándar define que todo objeto del que se ha movido queda en un estado válido pero no especificado. En otras palabras, mover de un objeto no lo destruye, y un objeto del que se ha movido tiene que seguir pudiendo usarse. Por lo general un objeto del que se ha movido se queda en un estado vacío, en el que no es propietario de ningún recurso. Eso significa que para toda clase que implementa operaciones de movimiento, existe un estado válido en el que el objeto está vacío. Éste es también el estado en el que el destructor no hace nada. Este estado es también único. Para un tipo que implementa operaciones de movimiento, existe un solo estado en el que no es propietario de ningún recurso. Este estado es un muy buen candidato para el estado al que inicializar con el constructor por defecto. Debería ser un estado prácticamente gratuito de alcanzar, y obvio para el lector. Es también la convención que sigue la biblioteca estándar, donde por defecto obtenemos contenedores vacíos, <code>unique_ptr nulo</code>, streams sin archivo… La biblioteca estándar es también muy consistente en lo contrario. Tipos que implementar un destructor pero no se pueden mover, como <code>lock_guard</code>, no son construibles por defecto, mientras que la alternativa que la biblioteca nos brinda que sí que es movible, <code>unique_lock</code>, sí que tiene un constructor por defecto que crea un objeto sin ningún mutex asociado.</p>

<p style='text-align: justify;'>Esta convención de tener que todo tipo que especialice las operaciones de mover sea construible por defecto y se inicialice al estado vacío en el que se queda al ser movido es un patrón de diseño muy sólido e intuitivo que ya está en uso por gran parte del código que usamos y deberíamos seguirla al implementar nuevos tipos que gestionen recursos.</p>
