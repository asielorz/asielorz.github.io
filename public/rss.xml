<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
  <channel>
    <title>Asier Elorz</title>
    <description>Un blog en el que escribo sobre lo que me apetece.</description>
    <link>https://asielorz.github.io</link>
    <copyright>2024 Asier Elorz Hernáez All rights reserved</copyright>
    <language>es-es</language>
    <lastBuildDate>Wed, 15 Jan 2025 00:00:00 +0000</lastBuildDate>    <item>
      <title>La razón instrumental y el té</title>
      <link>https://asielorz.github.io/posts/la-razon-instrumental-y-el-te</link>
      <guid>https://asielorz.github.io/posts/la-razon-instrumental-y-el-te</guid>
      <pubDate>Mon, 2 Dec 2024 00:00:00 +0000</pubDate>
      <image>https://asielorz.github.io/images/taza-de-te.png</image>
      <description><p>Este texto es una soberana tontería. Espero que al menos sea divertido.</p></description>
    </item>
    <item>
      <title>La razón instrumental y el té</title>
      <link>https://asielorz.github.io/posts/la-modelos-de-lenguaje-grandes-experiencia-usuario</link>
      <guid>https://asielorz.github.io/posts/la-modelos-de-lenguaje-grandes-experiencia-usuario</guid>
      <pubDate>Mon, 2 Dec 2024 00:00:00 +0000</pubDate>
      <image>https://asielorz.github.io/images/picard-earl-grey.png</image>
      <description><p>He leído recientemente argumentar que gran parte del entusiasmo por los modelos de lenguaje grandes (LLM por sus siglas en inglés) viene de la fantasía, proveniente de la ciencia ficción y sobre todo de Star Trek, de que sería guay controlar máquinas con lenguaje natural. Este análisis es extremadamente simplista.</p></description>
    </item>
    <item>
      <title>Anora es una comedia screwball</title>
      <link>https://asielorz.github.io/posts/anora-comedia-screwball</link>
      <guid>https://asielorz.github.io/posts/anora-comedia-screwball</guid>
      <pubDate>Sun, 17 Nov 2024 00:00:00 +0000</pubDate>
      <image>https://asielorz.github.io/images/anora-screwball.png</image>
      <description><p>Al principio me estaba costando leer <i>Anora</i> (Sean Baker, 2024). Durante el comienzo de la película no entendía muy bien qué estaba haciendo ni qué quería hacer. A ratos parecía que iba a ser algo tipo <i>Showgirls</i> (Paul Verhoeven, 1995) y a ratos simplemente veía a un grupo de chavales irse de fiesta. ¿Va a ser esto un comentario sobre el trabajo sexual? ¿Una modernización de la Cenicienta? ¿El mito de Fausto? ¿Quién son estos personajes y por qué son así? No me quedaba claro a dónde iba la cosa. Y entonces llega la escena de 25 minutos en la que los matones armenios del padre de Ivan le hacen una visita al chaval en su mansión de Nueva York. Esta escena es graciosísima. Es un caos de gritos y peleas y persecuciones. Hay slapstick, comentarios ingeniosos, cagadas ridículas, momentos de ternura y de violencia sin sentido. Todos estan como una cabra, cada uno va a su bola y todo sale mal. Es buenísima. Esta escena marca además el tono de lo que será el resto de la película. Y también me hace darme cuenta de lo que está haciendo la película: es una comedia screwball.</p></description>
    </item>
    <item>
      <title>Lo del demonio y la bufanda</title>
      <link>https://asielorz.github.io/posts/lo-del-demonio-y-la-bufanda</link>
      <guid>https://asielorz.github.io/posts/lo-del-demonio-y-la-bufanda</guid>
      <pubDate>Tue, 12 Nov 2024 00:00:00 +0000</pubDate>
      <image>https://asielorz.github.io/images/demonio-bufanda.png</image>
      <description><p>Un chiste que me he encontrado ya varias veces por internet es el que se cuenta en el tuit que encabeza este artículo. El chiste se basa en la intuición de que saber qué cosas son fáciles de programar y cuáles son difíciles es difícil para un profano. Una de las iteraciones más famosas de este chiste es <a href="https://xkcd.com/1425/">este xkcd</a>. Si este chiste se repite tanto es porque a nivel superficial resuena con experiencias que hemos tenido. Sin embargo, creo que puede ser interesante darle otra vuelta de tuerca. Tal vez la intuición del diseñador sobre cuánto trabajo lleva algo no está tan errada y es la respuesta del programador la que se está dejando cosas.</p></description>
    </item>
    <item>
      <title>Frostpunk y la política en el videojuego</title>
      <link>https://asielorz.github.io/posts/frostpunk-politica</link>
      <guid>https://asielorz.github.io/posts/frostpunk-politica</guid>
      <pubDate>Sun, 3 Nov 2024 00:00:00 +0000</pubDate>
      <image>https://asielorz.github.io/images/frostpunk.png</image>
      <description><p>Últimamente he estado jugando mucho a <i>Frostpunk</i>. Para los despistados, <i>Frostpunk</i> es un videojuego en el que el jugador toma el rol de alcalde de una ciudad en un mundo congelado donde la supervivencia es durísima. El juego consiste en tomar todas las decisiones de gobierno: qué leyes se aprueban, qué edificios se construyen y dónde, a qué tareas se dedica la fuerza de trabajo, qué se produce en las fábricas, qué avances tecnológicos se investigan, qué edificios tienen permitido encender la calefacción... Aunque tiene un modo infinito, el principal modo de juego consiste en varias historias en las que la ciudad tiene que sobrevivir a una serie de eventos a lo largo de varios días. Se gana llegando al último día habiendo cumplido los objetivos necesarios en cuestión de edificios construidos y recursos acumulados y habiendo evitado que muera toda la población. En cada historia hay también objetivos secundarios opcionales que el jugador puede intentar lograr si quiere.</p></description>
    </item>
    <item>
      <title>Estoy cansado de los Souls</title>
      <link>https://asielorz.github.io/posts/estoy-cansado-de-los-souls</link>
      <guid>https://asielorz.github.io/posts/estoy-cansado-de-los-souls</guid>
      <pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate>
      <image>https://asielorz.github.io/images/shadow-of-the-erdtree.png</image>
      <description><p>Jugando al DLC de <i>Elden Ring</i> estoy empezando a sentir que estoy cansado de la fórmula <i>Souls</i>. En este texto intento entender qué hay en el diseño de estos juegos que hace que a la larga terminen cansando. ¿Por qué jugar a <i>Elden Ring</i> no se siente como la primera vez que jugué a <i>Dark Souls</i>?</p></description>
    </item>
    <item>
      <title>A Wizards of the coast le favorece el mercado secundario de cartas</title>
      <link>https://asielorz.github.io/posts/wizards-mercado-secundario</link>
      <guid>https://asielorz.github.io/posts/wizards-mercado-secundario</guid>
      <pubDate>Sat, 27 Jul 2024 00:00:00 +0000</pubDate>
      <image>https://asielorz.github.io/images/black-lotus.png</image>
      <description><p>Si alguien juega o se ha planteado jugar a <i>Magic: The Gathering</i>, se habrá dado cuenta de que el mayor problema que tiene el juego es el precio. Jugar a <i>Magic</i> es muy caro. Yo me quedé de piedra cuando, tras una década sin jugar apenas, este año me planteé volver y descubrí que los precios de la mayoría de productos oficiales (sobres, mazos preconstruidos, inscripciones a torneos...) prácticamente se habían duplicado. Sin estar dentro, es bastante difícil de creer que un juego de mesa sea tan caro. Por lo general, se espera que un juego de mesa de 40€ traiga una caja grande, tablero, figuritas... Que sea algo elaborado y costoso de producir, como para justificar el precio. ¿Cómo puede ser que un mazo de 100 cartas, que es cartón impreso, valga 60€? ¿Por qué la gente lo paga?</p></description>
    </item>
    <item>
      <title>Tienes un e-mail y Orgullo y prejuicio</title>
      <link>https://asielorz.github.io/posts/tienes-un-email-orgullo-y-prejuicio</link>
      <guid>https://asielorz.github.io/posts/tienes-un-email-orgullo-y-prejuicio</guid>
      <pubDate>Sat, 13 Jul 2024 00:00:00 +0000</pubDate>
      <image>https://asielorz.github.io/images/tienes-un-email.png</image>
      <description><p><i>Tienes un e-mail</i> (Nora Ephron, 1998) es un remake poco ortodoxo de la película <i>El bazar de las sorpresas</i> (Ernst Lubitsch, 1940). Traslada la acción al presente y a la ciudad de Nueva York, y cambia los trabajos de los protagonistas. En esta versión, en vez de por carta los personajes hablan por email. Además de <i>El bazar de las sorpresas</i>, hay otra obra a la que la película hace referencias constantes: <i>Orgullo y prejuicio</i> de Jane Austen. El personaje de Meg Ryan reconoce que ha leído el libro unas 200 veces y que es su libro favorito. El personaje de Hanks intenta leerlo y se aburre, pero más tarde demuestra su conocimiento de la obra cuando vuelve a salir en sus conversaciones.</p></description>
    </item>
    <item>
      <title>King Park en directo es un espectáculo grotesco</title>
      <link>https://asielorz.github.io/posts/king-park-directo</link>
      <guid>https://asielorz.github.io/posts/king-park-directo</guid>
      <pubDate>Fri, 28 Jun 2024 00:00:00 +0000</pubDate>
      <image>https://asielorz.github.io/images/jordan-dreyer.png</image>
      <description><p>En el canal de YouTube del grupo de post-hardcore <i>La Dispute</i> hay una grabación de una actuación en directo en la que cantan <i>King Park</i>. Me gusta mucho <i>La Dispute</i>. La forma en la que Jordan Dreyer trata temas durísimos en sus letras, la emoción pura, cruda, incontenida, en cada verso, esa voz que no es canto, ni grito, ni llanto, ni habla sino una mezcla de todas ellas y consigue removerte por dentro. También se podría decir mucho sobre su instrumentación, con elementos de rock, de metal, de jazz... Me gusta mucho <i>La Dispute</i>, he escuchado sus discos durante horas y horas, por eso no me esperaba que el vídeo de una actuación en directo me produjera semejante rechazo. ¿Qué ha pasado?</p></description>
    </item>
    <item>
      <title>El síndrome del impostor dura dos meses</title>
      <link>https://asielorz.github.io/posts/sindrome-del-impostor-dos-meses</link>
      <guid>https://asielorz.github.io/posts/sindrome-del-impostor-dos-meses</guid>
      <pubDate>Mon, 24 Jun 2024 00:00:00 +0000</pubDate>
      <description><p>Nunca he entrado a un puesto de trabajo con la confianza de saber lo que estaba haciendo. Siempre que he empezado en un nuevo sitio lo he hecho con el miedo de no tener los conocimientos necesarios para hacer el trabajo que estaba haciendo, y de alguna forma haber engañado a las personas que me estaban entrevistando para convencerles de lo contrario. Al fin y al cabo, las entrevistas de trabajo son situaciones muy regladas y con roles y expectativas muy claras, y es muy fácil trucarlas y hacer a la otra parte pensar lo que quieres que piense de ti. Lo que estoy describiendo se llama síndrome del impostor. La sensación errónea de que no tienes la capacidad para hacer el puesto de trabajo en el que te encuentras, de que has llegado ahí mediante el engaño y el miedo a ser descubierto y sufrir consecuencias por ello. Por lo general se habla mucho sobre el síndrome del impostor en el caso del primer trabajo. Es normal que uno sienta que no tiene ni idea la primera vez que pone los pies fuera de la universidad y se tiene que enfrentar a un proyecto y una situación laboral de verdad. Sin embargo, yo tenía la esperanza de que esto dejara de suceder con el tiempo. Que conforme fuera adquiriendo experiencia dejaría de sentirme así al empezar nuevos trabajos. La sorpresa que me produce que no sea así es lo que me lleva a escribir este texto.</p></description>
    </item>
    <item>
      <title>¿No son los bosses de Another crab&apos;s treasure un poco sosos?</title>
      <link>https://asielorz.github.io/posts/bosses-another-crabs-treasure</link>
      <guid>https://asielorz.github.io/posts/bosses-another-crabs-treasure</guid>
      <pubDate>Sat, 1 Jun 2024 00:00:00 +0000</pubDate>
      <image>https://asielorz.github.io/images/inkerton.png</image>
      <description><p>Aunque me gustó bastante, una sensación negativa que me dejó <i>Another crab&apos;s treasure</i> es una ligera decepción en el diseño de sus bosses. No es que estén mal, pero son bastante sosos. Les falta algo. Un no sé qué. En este texto intentaremos averiguar qué es.</p></description>
    </item>
    <item>
      <title>Filosofía del derecho en Ace Attorney</title>
      <link>https://asielorz.github.io/posts/filosofia-derecho-ace-attorney</link>
      <guid>https://asielorz.github.io/posts/filosofia-derecho-ace-attorney</guid>
      <pubDate>Sat, 27 Apr 2024 00:00:00 +0000</pubDate>
      <image>https://asielorz.github.io/images/ace-attorney-chronicles.png</image>
      <description><p>Este texto destripa el final de <i>The Great Ace Attorney Chronicles</i>, además de comentar puntos importantes de la trama de varios juegos de la trilogía <i>Phoenix Wright: Ace Attorney</i>. Se recomienda encarecidamente jugar a los juegos antes de seguir leyendo, ya que el principal atractivo de los juegos de <i>Ace Attorney</i> está en el aspecto narrativo. Continúa leyendo bajo tu propia responsabilidad.</p></description>
    </item>
    <item>
      <title>Conocimiento necesario</title>
      <link>https://asielorz.github.io/posts/conocimiento-necesario</link>
      <guid>https://asielorz.github.io/posts/conocimiento-necesario</guid>
      <pubDate>Sun, 11 Feb 2024 00:00:00 +0000</pubDate>
      <description><p>El otro día hablando con un amigo surgió el tema de seguir leyendo o estudiando sobre informática más allá de la carrera. Es evidente que 4 años no dan para aprender la totalidad de la informática (ni de ningún otro campo del saber) y que todavía queda mucho por aprender después de dejar la universidad. La parte en la que no estaba de acuerdo con él es en que dijo que él sólo lee sobre cosas cuando las necesita mientras que a mí me gusta leer sobre problemas que no tengo porque sí, porque son interesantes, y creo que el hacerlo es beneficioso.</p></description>
    </item>
    <item>
      <title>El plagio de Palworld es parte del chiste</title>
      <link>https://asielorz.github.io/posts/palworld</link>
      <guid>https://asielorz.github.io/posts/palworld</guid>
      <pubDate>Tue, 23 Jan 2024 00:00:00 +0000</pubDate>
      <image>https://asielorz.github.io/images/palworld.png</image>
      <description><p>Me tiene bastante sorprendido un fenómeno concreto de la recepción del reciente videojuego <i>Palworld</i> (Pocketpair, 2024). Concretamente, la cantidad de acusaciones de plagio a <i>Pokémon</i>, algunas más chistosas como <a href="https://hard-drive.net/hd/video-games/palworld-execs-brace-for-hbomberguy-video/">este artículo de la revista satírica Hard Drive</a> y otras más indignadas como <a href="https://twitter.com/CeciliaFae/status/1749183481325015058">el hilo de Twitter que va criatura a criatura del juego analizando qué pokemon copia</a>. La sorpresa no viene porque estas acusaciones estén infundadas. Es evidente el plagio descarado de diseños de criaturas a la saga de juegos de Nintendo. La sorpresa viene por el formato. Una acusación se hace cuando se revela un delito o un comportamiento reprobable llevado a cabo por alguien cuando este comportamiento no es conocido. Del conocimiento público se espera por lo general algún tipo de castigo, ya sea social o penal. La razón por la que me sorprende que alguien se crea en la necesidad de hacer esta acusación es porque me cuesta entender que alguien piense que este plagio no es evidente.</p></description>
    </item>
    <item>
      <title>Gangs of New York, dos roedores y cierto tradicional desayuno castellano</title>
      <link>https://asielorz.github.io/posts/gangs-of-new-york</link>
      <guid>https://asielorz.github.io/posts/gangs-of-new-york</guid>
      <pubDate>Sun, 26 Nov 2023 00:00:00 +0000</pubDate>
      <image>https://asielorz.github.io/images/gangs-of-new-york.png</image>
      <description><p>Entre 1845 y 1849 una enfermedad afectó a los cultivos de patata de toda Europa, reduciendo drásticamente la producción de las cosechas. En Irlanda la dieta de gran parte de la población dependía en gran medida de la patata como fuente principal de hidratos de carbono. Esta enfermedad causó lo que se conoce como la hambruna de la patata irlandesa, que causó la muerte de cerca de un millón de irlandeses y la emigración de otro millón fuera de Irlanda. Muchos de ellos viajaron a Estados Unidos. Nueva York recibió en aquellos años un aluvión de inmigrantes irlandeses que viajaban desde Europa huyendo del hambre. Esta llegada masiva de inmigración irlandesa provocó sentimientos de xenofobia en parte de la población local y fue causa de disturbios raciales en la ciudad.</p></description>
    </item>
    <item>
      <title>El final de I care a lot es bastante ingenuo</title>
      <link>https://asielorz.github.io/posts/final-i-care-a-lot-ingenuo</link>
      <guid>https://asielorz.github.io/posts/final-i-care-a-lot-ingenuo</guid>
      <pubDate>Thu, 12 Oct 2023 00:00:00 +0000</pubDate>
      <image>https://asielorz.github.io/images/i-care-a-lot.png</image>
      <description><p><i>I care a lot</i> (J Blakeson, 2020) es un thriller genial sobre una mujer que dirige una empresa de cuidados de personas ancianas. La empresa en realidad tiene como objetivo estafar a estas personas, compinchándose con sus médicos para que falsifiquen sus historias exagerando los rasgos de incapacidad para que un juez falle a favor de asignarles un tutor legal. Marla Grayson, interpretada por Rosamund Pike, entonces interna a la persona en una residencia de confianza en la que sabe que no tendrá acceso a teléfono ni a visitas de sus familiares y gestiona sus bienes para vender todas las propiedades y transferir el dinero a su cuenta en forma de pago por los servicios. El thriller comienza cuando sin saberlo intenta estafar de esta manera a la madre de un capo de la mafia, convirtiéndose así en objetivo del crimen organizado. La interpretación de Pike haciendo de mala vuelve a ser tan espectacular como en <i>Gone girl</i> (David Fincher, 2014).</p></description>
    </item>
    <item>
      <title>Una breve reflexión sobre identidad y consumo</title>
      <link>https://asielorz.github.io/posts/reflexion-identidad-consumo</link>
      <guid>https://asielorz.github.io/posts/reflexion-identidad-consumo</guid>
      <pubDate>Fri, 22 Sep 2023 00:00:00 +0000</pubDate>
      <description><p>Los que hayáis cometido alguna vez el error de entrar en redes sociales no seréis ajenos al esperpéntico espectáculo de personas adultas atacando con virulencia alguna película, serie, libro, disco de música u otra producción cultural. La campaña de odio en torno a la octava película de la saga <i>Star Wars</i> es un buen ejemplo de este fenómeno. Concretamente con esta película, aunque es cierto que es la más marcadamente feminista de la saga, y que la mayoría de sus detractores de internet eran hombres de derechas, creo que la explicación tiene que ir más allá. Hay muchas películas feministas, y no todas reciben una avalancha de odio de esta magnitud. Simplificar el fenómeno a que las películas con cierto mensaje político son criticadas ignora mucho contexto.</p></description>
    </item>
    <item>
      <title>Simulaciones determinísticas reproducibles y su aplicación al desarrollo de videojuegos</title>
      <link>https://asielorz.github.io/posts/simulaciones-deterministicas-reproducibles</link>
      <guid>https://asielorz.github.io/posts/simulaciones-deterministicas-reproducibles</guid>
      <pubDate>Sat, 22 Jul 2023 00:00:00 +0000</pubDate>
      <description><p>Este texto expone una serie de técnicas e ideas que se pueden usar en el desarrollo de videojuegos para solucionar diferentes problemas. Aunque tengo experiencia usando simulaciones determinísticas reproducibles, no he implementado todas ellas y algunas están aquí en parte para dejar constancia de la idea, por si en el futuro escribo otro videojuego, para acordarme de ellas y probarlas.</p></description>
    </item>
    <item>
      <title>Has obtenido una flor de alma</title>
      <link>https://asielorz.github.io/posts/has-obtenido-una-flor-de-alma</link>
      <guid>https://asielorz.github.io/posts/has-obtenido-una-flor-de-alma</guid>
      <pubDate>Mon, 10 Jul 2023 00:00:00 +0000</pubDate>
      <image>https://asielorz.github.io/images/spiritfarer.png</image>
      <description><p>Caronte se jubila. Es tu primer día de trabajo guiando a las almas al Hades a cambio de un óbolo. De esto trata <i>Spiritfarer</i> (Thunder Lotus Games, 2020), un videojuego independiente en el que el jugador toma el control de Stella y su barco en el oficio de guiar almas al más allá. Es un videojuego con un fuerte peso narrativo, personajes complejos y un gran trabajo de guion. Es también un RPG y juego de gestión de recursos en el que el jugador tiene que recorrer los mares en busca de ingredientes con los que cocinar y materiales con los que mejorar su barco. Estas dos facetas del juego chocan en ocasiones.</p></description>
    </item>
    <item>
      <title>La pureza de las funciones impuras</title>
      <link>https://asielorz.github.io/posts/la-pureza-de-las-funciones-impuras</link>
      <guid>https://asielorz.github.io/posts/la-pureza-de-las-funciones-impuras</guid>
      <pubDate>Tue, 20 Jun 2023 00:00:00 +0000</pubDate>
      <description><p>Hemos hablado en el pasado de que <a href="/posts/malloc-es-especial">malloc es especial</a> y de que <a href="/posts/concurrencia-estructurada-especial">la concurrencia estructurada también es especial</a>. Hoy vamos a ver cómo lidian los lenguajes de programación funcionales con las funciones puras que necesitan efectos secundarios como parte de su implementación, y a explorar el espacio de diseño para buscar alternativas.</p></description>
    </item>
    <item>
      <title>El club del odio usa un giro de trama para reforzar su mensaje</title>
      <link>https://asielorz.github.io/posts/el-club-del-odio-giro</link>
      <guid>https://asielorz.github.io/posts/el-club-del-odio-giro</guid>
      <pubDate>Sat, 13 May 2023 00:00:00 +0000</pubDate>
      <image>https://asielorz.github.io/images/el-club-del-odio.png</image>
      <description><p>Este texto destripa un importante giro de trama que sucede a la mitad de <i>El club del odio</i> (Beth de Araújo, 2022). De hecho, el objetivo de este texto es alabar cómo la película usa el pillar por sorpresa al espectador para reforzar su mensaje. Por ello, se recomienda encarecidamente ver la película antes de seguir leyendo. Proceda bajo su propio riesgo.</p></description>
    </item>
    <item>
      <title>No son los pulsos, es el botón de interacción</title>
      <link>https://asielorz.github.io/posts/pulso-boton-interaccion</link>
      <guid>https://asielorz.github.io/posts/pulso-boton-interaccion</guid>
      <pubDate>Mon, 17 Apr 2023 00:00:00 +0000</pubDate>
      <description><p>No soy muy fan de <i>Leyendas y videojuegos</i>, pero de vez en cuando YouTube me recomienda sus vídeos y alguno me veo, y uno de los últimos me sirve para hablar de un tema de diseño de videojuegos sobre el que llevo un tiempo reflexionando, así que vamos allá. Dejo aquí el vídeo de Eric, pero, por resumir, critica la mecánica muy frecuente en videojuegos triple A de pulsar un botón para destacar todos los objetos interactivos a la vista. Mecánica que cada juego nombra de una forma distinta (el modo detective del <i>Batman</i>, el sentido de brujo del <i>Witcher</i>…) pero a la que llamaremos “pulso” por usar la misma nomenclatura que el vídeo.</p></description>
    </item>
    <item>
      <title>El uso que la web3 hace de la tecnología blockchain no resuelve problemas fundamentales de la propiedad privada</title>
      <link>https://asielorz.github.io/posts/blockchain-web3-no-resuelve-propiedad-privada</link>
      <guid>https://asielorz.github.io/posts/blockchain-web3-no-resuelve-propiedad-privada</guid>
      <pubDate>Wed, 5 Apr 2023 00:00:00 +0000</pubDate>
      <description><p>La propiedad privada es complicada. Ante todo, es una abstracción. Los objetos no son propiedad de las personas excepto en las imaginaciones de las personas. Es lo que Harari llama en <i>Sapiens</i> una realidad imaginada. Nuestra relación con la propiedad privada es compleja y opera a distintos niveles así que intentar inventar una nueva forma de propiedad privada como pretende hacer la tecnología blockchain es un objetivo ambicioso. En este texto trataremos de entender a grandes rasgos cómo funciona la propiedad privada y de qué forma blockchain, o el uso que hace de esta tecnología la llamada web3, se queda corto en muchos aspectos.</p></description>
    </item>
    <item>
      <title>Sobre reescribir código</title>
      <link>https://asielorz.github.io/posts/sobre-reescribir-codigo</link>
      <guid>https://asielorz.github.io/posts/sobre-reescribir-codigo</guid>
      <pubDate>Mon, 6 Mar 2023 00:00:00 +0000</pubDate>
      <description><p>Leyendo hace poco <a href="https://blog.axo.dev/2023/02/cargo-dist-rewrite">un artículo</a> de Aria Beingessner “Gankra” sobre el desarrollo de la herramienta cargo-dist, me choca cómo explica que de la versión 0.0.2 a la 0.0.3 ha reescrito todo el código de cero. Y me choca, por supuesto, porque no solemos hacer eso. Solemos desarrollar programas de forma iterativa, modificando poco a poco lo anterior para añadir nuevas cosas y corregir errores. Este tipo de gran reescritura suele ser muy raro y terminal mal. Por eso, es curioso ver una historia de éxito, y podría ser valioso analizarla.</p></description>
    </item>
    <item>
      <title>Muchos programadores nunca escriben abstracciones</title>
      <link>https://asielorz.github.io/posts/muchos-programadores-nunca-escriben-abstracciones</link>
      <guid>https://asielorz.github.io/posts/muchos-programadores-nunca-escriben-abstracciones</guid>
      <pubDate>Wed, 1 Mar 2023 00:00:00 +0000</pubDate>
      <description><blockquote><p>&quot;El propósito de la abstracción no es ser impreciso, sino crear un nuevo nivel semántico en el que uno puede ser absolutamente preciso.&quot;</p></blockquote></description>
    </item>
    <item>
      <title>El viaje rápido cambia nuestra relación con el mundo abierto</title>
      <link>https://asielorz.github.io/posts/viaje-rapido-mundo-abierto</link>
      <guid>https://asielorz.github.io/posts/viaje-rapido-mundo-abierto</guid>
      <pubDate>Sun, 26 Feb 2023 00:00:00 +0000</pubDate>
      <description><p>Recientemente he terminado <i>Sable</i>, un juego independiente donde el jugador toma el papel de una chica que, en su mundo de ciencia ficción, como ritual de paso de la niñez a la madurez, emprende un viaje para conocer el mundo y encontrar su lugar en él. Es un juego de mundo abierto donde los pilares principales son la exploración y las pequeñas historias de la gente que uno va encontrando. El mundo del juego está totalmente abierto desde el principio y, aunque se sugiere al jugador que comience por cierta zona, tiene libertad total para ir a donde quiera, explorar en el orden que le apetezca e incluso terminar la partida en cuanto considere que ha encontrado lo que buscaba. Tampoco hay combate, ni muerte, ni condición de derrota de ningún tipo que pueda bloquear en la práctica zonas porque son demasiado difíciles hasta haber subido varias veces de nivel. Conforme el jugador va encontrando lugares importantes como ciudades, campamentos o ruinas, desbloquea en el mapa un indicador señalando su posición y la posibilidad de teletransportarse a ellas desde cualquier otro lado. Lo que se conoce como viaje rápido y es una mecánica muy común de la mayoría de juegos de mundo abierto. Pues bien, yo no descubrí que se podía hacer esto hasta prácticamente el final.</p></description>
    </item>
    <item>
      <title>Al roguelike le va bien el formato del DLC</title>
      <link>https://asielorz.github.io/posts/roguelike-dlc</link>
      <guid>https://asielorz.github.io/posts/roguelike-dlc</guid>
      <pubDate>Tue, 14 Feb 2023 00:00:00 +0000</pubDate>
      <description><p>Últimamente me ha vuelto a dar por jugar al <i>Dead cells</i>. Es un juego que me gusta mucho y al que vuelvo periódicamente, y el hecho de que este mes sacan el siguiente DLC era una excusa tan buena como cualquier otra para desempolvarlo. Llevo jugando desde que el juego estaba en acceso anticipado así que he podido ver cómo ha cambiado este juego a lo largo de los años, y me parece un ejemplo perfecto de cómo el DLC puede ser el formato idóneo para seguir capitalizando un juego del género roguelike.</p></description>
    </item>
    <item>
      <title>Un argumento a favor de nombrar sistemas internos</title>
      <link>https://asielorz.github.io/posts/argumento-a-favor-de-nombrar-sistemas-internos</link>
      <guid>https://asielorz.github.io/posts/argumento-a-favor-de-nombrar-sistemas-internos</guid>
      <pubDate>Mon, 13 Feb 2023 00:00:00 +0000</pubDate>
      <description><p>Una práctica algo común en algunos proyectos de software es el nombrar con nombres propios sistemas internos, que no son parte de la interfaz pública y sólo son visibles para el equipo. Recuerdo que esta práctica me frustraba mucho cuando entré a mi primer trabajo, porque hacía que saber qué era cada cosa fuera mucho más difícil. Me pasaba el día preguntándome por qué alguien en su sano juicio llamaría a su sistema <a href="https://www.youtube.com/watch?v=y8OnoxKotPQ">Galactus</a> en vez de “agregador de proveedores de información”. Y la verdad es que hasta ahora no había encontrado ningún argumento de peso a favor de esta práctica, a la que desde luego le veo muchos en contra. Pero desde hoy, por fin, tengo al menos un argumento a favor de nombrar sistemas internos. Puede facilitar algunas tomas de decisiones a la hora de reutilizar código a largo plazo.</p></description>
    </item>
    <item>
      <title>Reusar código es difícil</title>
      <link>https://asielorz.github.io/posts/reusar-codigo-es-dificil</link>
      <guid>https://asielorz.github.io/posts/reusar-codigo-es-dificil</guid>
      <pubDate>Mon, 13 Feb 2023 00:00:00 +0000</pubDate>
      <description><p>Se habla mucho sobre reusar código, escribir código reusable, no reinventar la rueda, ser eficiente… Depende de a quién se escuche parece que reusar código es un objetivo a buscar siempre. Todo el código debería ser escrito para poder ser reusado en el futuro, y todo código nuevo debería buscar reusar soluciones anteriores antes que reescribir soluciones parecidas de cero. Por un lado, es cierto que reusar código es útil y hecho correctamente puede ayudar a un equipo a ahorrar tiempo y esfuerzo a largo plazo. Por otro lado, contra lo que podríamos intuir, reusar código no es gratis. Se suele pensar en el código escrito en el pasado como algo que “ya está hecho”, y se suele ignorar el trabajo necesario para adaptarlo al contexto y los problemas actuales. Tener en cuenta este coste nos puede llevar a tomar mejores decisiones respecto a cuándo se debería reusar código y cuándo tiene más sentido escribir una solución nueva.</p></description>
    </item>
    <item>
      <title>Jonathan Blow en su fase trumpista</title>
      <link>https://asielorz.github.io/posts/jonathan-blow-fase-trumpista</link>
      <guid>https://asielorz.github.io/posts/jonathan-blow-fase-trumpista</guid>
      <pubDate>Sun, 5 Feb 2023 00:00:00 +0000</pubDate>
      <description><p>Me cuesta saber cómo empezar este texto porque siempre es difícil darse cuenta de lo malo de alguien a quien se ha admirado. Para los despistados, un poco de contexto. Jonathan Blow es un conocido diseñador y programador de videojuegos, famoso sobre todo por dirigir <i>Braid</i> y <i>The witness</i>, dos grandes obras del videojuego independiente de puzles. En la actualidad, se encuentra desarrollando su siguiente videojuego, además de su propio lenguaje de programación con el objetivo de crear un lenguaje especialmente diseñado para escribir videojuegos. Blow es también en cierta medida una persona pública, con una gran presencia a través de charlas en conferencias, entrevistas, redes sociales y sus canales de Twitch y YouTube, donde retransmite en directo sesiones de programación o divulga sobre informática en un tono más informal que una conferencia.</p></description>
    </item>
    <item>
      <title>Hay una cantidad correcta de relleno</title>
      <link>https://asielorz.github.io/posts/cantidad-aceptable-de-relleno</link>
      <guid>https://asielorz.github.io/posts/cantidad-aceptable-de-relleno</guid>
      <pubDate>Fri, 11 Nov 2022 00:00:00 +0000</pubDate>
      <description><p>Una de las quejas que más se hizo sobre las últimas temporadas de <i>Steven Universe</i> fue el relleno. El que en medio de dos capítulos que avanzaban la trama principal metieran uno en el que Steven se va a la isla de las sandías vivientes a perder el tiempo. Yo vi la serie ya terminada así que estas interrupciones no me importaron demasiado, pero puedo entender que alguien que seguía la serie semana a semana se frustrara cuando el capítulo de la semana trataba sobre la isla de las sandías o alguna otra subtrama irrelevante similar. Sin embargo, las primeras temporadas de <i>Steven Universe</i> tienen mucho más “relleno” que las últimas. La estructura sería más bien la de una serie de episodios casi independientes con un mínimo de trama avanzando poco a poco. Algo así como <i>Rick y Morty</i>. Este tuit recoge bastante bien ese contraste:</p></description>
    </item>
    <item>
      <title>¿Puedo confiar en este programa?</title>
      <link>https://asielorz.github.io/posts/puedo-fiarme-de-este-programa</link>
      <guid>https://asielorz.github.io/posts/puedo-fiarme-de-este-programa</guid>
      <pubDate>Sat, 5 Nov 2022 00:00:00 +0000</pubDate>
      <description><p>Este es un texto que deberías poder enseñar a tus padres para explicarles unos mínimos de cómo no ser estafado en internet.</p></description>
    </item>
    <item>
      <title>Works-as-implemented</title>
      <link>https://asielorz.github.io/posts/works-as-implemented</link>
      <guid>https://asielorz.github.io/posts/works-as-implemented</guid>
      <pubDate>Wed, 26 Oct 2022 00:00:00 +0000</pubDate>
      <description><p>Llevo obsesionado con la idea de <i>works-as-implemented</i> desde que vi a Sean Parent presentarla en <a href="https://www.youtube.com/watch?v=2FAi2mNYjFA">su charla de la CppCon de 2021</a>, publicada hace unos meses. Es un concepto mucho más profundo y con más ramificaciones de lo que podría parecer, y creo que merece la pena dedicar un texto a indagar en qué estamos diciendo y sobre qué estamos hablando cuando decimos que un trozo de código funciona como está implementado. Seguidme pues en este artículo en el que hablaremos sobre semántica, diseño por contrato, la ley de Hyrum y código que cambia a lo largo del tiempo.</p></description>
    </item>
    <item>
      <title>El operador pizza y el functor aplicativo</title>
      <link>https://asielorz.github.io/posts/operador-pizza-functor-aplicativo</link>
      <guid>https://asielorz.github.io/posts/operador-pizza-functor-aplicativo</guid>
      <pubDate>Wed, 12 Oct 2022 00:00:00 +0000</pubDate>
      <description><p>Elm tiene un operador, <code>|&amp;gt;</code>, que permite escribir de una forma distinta una expresión que llama a una función. Si de normal escribiríamos llamar a una función f con los parámetros a, b y c como <code>f a b c</code>, también podemos escribirlo como <code>c |&amp;gt; f a b</code>. El operador simplemente reescribe la expresión para que c sea el último parámetro de la llamada a la función. Este operador, conocido cómicamente como el operador pizza debido a su forma triangular, también existe en otros lenguajes de programación, y aunque dependiendo del lenguaje su significado es ligeramente distinto, sobre todo alterando si la expresión a la izquierda se pasa como el último parámetro de la función o como el primero según lo que sea más idiomático en ese lenguaje, hace más o menos lo mismo en todos.</p></description>
    </item>
    <item>
      <title>Desarrollar intuición para el functor aplicativo</title>
      <link>https://asielorz.github.io/posts/intuicion-functor-aplicativo</link>
      <guid>https://asielorz.github.io/posts/intuicion-functor-aplicativo</guid>
      <pubDate>Sun, 9 Oct 2022 00:00:00 +0000</pubDate>
      <description><p>Suele pasar con las estructuras algebraicas que, al ser muy abstractas, es difícil entender a partir de la definición qué idea representan. Al programar, no tener una intuición sobre las propiedades de una estructura algebraica puede hacer que no diseñemos nuestros tipos de datos para satisfacer sus axiomas, aun pudiendo, y no obtengamos el beneficio de todos los teoremas y algoritmos desarrollados para esta estructura. El functor aplicativo es una estructura de datos especialmente abstrusa y sorprendentemente útil una vez entendida. Este texto intentará ofrecer una intuición para entender cuál es el propósito detrás de esta estructura algebraica. No prometo que uno saldrá de haber leído este texto sabiendo lo que es un functor aplicativo, al fin y al cabo desarrollar intuición requiere tiempo y práctica y es difícil atajar, pero se hará lo que se pueda. Al menos, se intentará abstenerse de metáforas descabelladas y referencias a la gastronomía mexicana.</p></description>
    </item>
    <item>
      <title>La documentación es mala (o inexistente) porque no se valora</title>
      <link>https://asielorz.github.io/posts/la-documentacion-no-se-valora</link>
      <guid>https://asielorz.github.io/posts/la-documentacion-no-se-valora</guid>
      <pubDate>Fri, 30 Sep 2022 00:00:00 +0000</pubDate>
      <description><p>El estudio <a href="https://services.google.com/fh/files/misc/state-of-devops-2021.pdf"><i>State of DevOps 2021</i></a> es poco ambiguo al respecto: “los equipos con documentación de calidad están más capacitados para implementar prácticas técnicas y funcionar mejor en su conjunto”. Entre otras cosas, son 3,8 veces más propensos a tener buenas prácticas de seguridad informática y es 2,4 veces más probable que alcancen consistentemente sus objetivos de negocio. La buena documentación no sólo facilita el día a día y hace más fácil y agradable el trabajo, también está ligado de forma estadísticamente significativa a un mejor rendimiento del equipo. Puedes pasarle esa cita y esos números a tu jefe. Sin embargo, esta no es la experiencia habitual en entornos profesionales de desarrollo de software. Con frecuencia, la documentación suele ser pobre, incompleta y a menudo desfasada, si es que existe para empezar. Y cabe preguntarse por qué es tan frecuente ignorar una práctica que intuitivamente es evidente que es beneficiosa y para la que ahora tenemos evidencia estadística. La tesis de este texto es que culturalmente la documentación no se valora.</p></description>
    </item>
    <item>
      <title>La concurrencia estructurada también es especial</title>
      <link>https://asielorz.github.io/posts/concurrencia-estructurada-especial</link>
      <guid>https://asielorz.github.io/posts/concurrencia-estructurada-especial</guid>
      <pubDate>Thu, 15 Sep 2022 00:00:00 +0000</pubDate>
      <description><p>Decíamos en su día que <a href="/posts/malloc-es-especial">malloc es especial</a>. Con ello queríamos decir que, a pesar de causar efectos secundarios en el sistema operativo, en la práctica podemos tratar malloc como una función pura, o al menos considerar que una función que llama a malloc no por ello deja de ser pura. El texto terminaba preguntándose qué más funciones son especiales. Hoy tenemos un nuevo ejemplo: la concurrencia estructurada también es especial.</p></description>
    </item>
    <item>
      <title>Cult of the lamb: la fantasía de poder amable</title>
      <link>https://asielorz.github.io/posts/cult-of-the-lamb-fantasia-de-poder-amable</link>
      <guid>https://asielorz.github.io/posts/cult-of-the-lamb-fantasia-de-poder-amable</guid>
      <pubDate>Wed, 31 Aug 2022 00:00:00 +0000</pubDate>
      <description><p>Cuando se habla sobre fantasías de poder en el videojuego, la primera imagen que viene a la cabeza es un personaje enfrentándose solo a decenas de enemigos y saliendo vivo dejando a su paso decenas de cadáveres. Juegos como los primeros <i>God of war</i>, de los que el director dijo que intentaba hacer un juego que a su yo de 12 años le habría encantado jugar. Aunque ciertamente este tipo de juegos son una fantasía de poder, reducir el término a ellos es muy reduccionista. En última instancia, una fantasía de poder es una simplificación enorme de un problema muy complejo, de forma que es manejable y superable por una sola persona en su tiempo de ocio, mientras se le crea la ilusión de que está lidiando con algo parecido al problema real. Desde este punto de vista, juegos como <i>Cities Skylines</i>, <i>Civilization</i> o <i>Europa Universalis</i> son fantasías de poder, que simplifican la gestión de una ciudad o un país hasta el extremo de hacer que la mayoría de decisiones y consecuencias están bajo el control del jugador. Creo que no hace falta explicar que gestionar un país de verdad es un problema mucho más difícil de lo que plantea un juego de Paradox Interactive, incluso siendo estos juegos muy complejos y café para muy cafeteros. Sobre todo, hay muchísimas decisiones que no están bajo el control del gobierno. Sin embargo, en una época de opiniones de barra de bar y afirmaciones de que “lo de Ucrania (o el paro, el precio de la luz, la inflación…) te lo arreglo yo en dos semanas”, este tipo de juegos aportan la fantasía perfecta para alimentar esas creencias simplistas, esa ilusión de que efectivamente uno podría arreglar un conflicto bélico internacional en dos semanas, si tan sólo le dejaran. No es difícil encontrar por Twitter o Reddit anécdotas de gente que en uno de estos juegos ha decidido jugar como la nación más pobre del tercer mundo y la termina convirtiendo en un imperio donde nunca se pone el sol. ¿Cómo no iban a hacer lo mismo con un país de verdad?</p></description>
    </item>
    <item>
      <title>Manderlay trata sobre lo ridículo del salvador blanco</title>
      <link>https://asielorz.github.io/posts/manderlay-salvador-blanco</link>
      <guid>https://asielorz.github.io/posts/manderlay-salvador-blanco</guid>
      <pubDate>Tue, 30 Aug 2022 00:00:00 +0000</pubDate>
      <description><p>El salvador blanco es un arquetipo muy frecuente en la narrativa occidental. El personaje blanco, frecuentemente masculino, que llega a una tierra lejana a luchar por los nativos y solucionar todos sus problemas. Los ejemplos son muchos, desde <i>Lawrence de Arabia</i> (David Lean, 1962) uniendo a las tribus árabes para luchar contra el imperio británico, a su remake de ciencia ficción, la novela <i>Dune</i> de Frank Herbert adaptada al cine por David Lynch (1984) y Dennis Villeneuve (2021), pasando por <i>Avatar</i> (James Cameron, 2009) con un militar estadounidense enseñando a luchar a los alienígenas o <i>Indiana Jones y el templo maldito</i> (Steven Spielberg, 1984), donde el famoso arqueólogo libera a una tribu del Himalaya de una malvada secta que sacrificaba humanos para su dios. También lo es <i>La lista de Schindler</i> (Steven Spielberg, 1993), sobre el empresario alemán bien conectado con el gobierno nazi que usa su influencia y dinero para salvar la vida a judíos durante el Holocausto. Es un arquetipo que se repite constantemente en obras muy populares de la historia del cine y que a estas alturas tenemos ya muy interiorizado. Sin embargo, conforme se analizan estas obras desde una lente anticolonialista, el arquetipo del salvador blanco va perdiendo poco a poco su lustre.</p></description>
    </item>
    <item>
      <title>Los golpes críticos en Cult of the lamb</title>
      <link>https://asielorz.github.io/posts/golpes-criticos-cult-of-the-lamb</link>
      <guid>https://asielorz.github.io/posts/golpes-criticos-cult-of-the-lamb</guid>
      <pubDate>Wed, 24 Aug 2022 00:00:00 +0000</pubDate>
      <description><p><i>Cult of the lamb</i> es un juego en el que el jugador tiene que alternar entre construir un pueblo, alimentar a sus habitantes y mantenerlos contentos con adentrarse en mazmorras en busca de objetos valiosos, nuevos habitantes que rescatar para que se unan al pueblo y combates contra jefes que al ser derrotados avanzan la historia. El juego tiene una estructura muy similar a <i>Moonlighter</i>, con cuatro zonas de dificultad ascendiente, cada una con su jefe final y mazmorras autogeneradas compuestas por salas como las de un roguelike. Al completar una mazmorra o ser derrotado el jugador vuelve al pueblo a invertir lo obtenido durante la mazmorra en mejorar el pueblo. Durante las mazmorras, el gameplay consiste en salas del tamaño de la pantalla o un poco más grandes en las que el jugador se mueve en dos dimensiones, visto desde arriba, y se enfrenta a espadazos con enemigos con patrones de ataque muy simples, al estilo del antes mencionado <i>Moonlighter</i> o los <i>Zeldas</i> clásicos.</p></description>
    </item>
    <item>
      <title>Los atajos en Tunic</title>
      <link>https://asielorz.github.io/posts/atajos-en-tunic</link>
      <guid>https://asielorz.github.io/posts/atajos-en-tunic</guid>
      <pubDate>Sun, 21 Aug 2022 00:00:00 +0000</pubDate>
      <description><p>Tal vez el elemento más característico del diseño de niveles de los <i>Souls</i> sea el atajo. La puerta que no se abre desde este lado. El ascensor que convenientemente conecta la hoguera con el jefe de la zona pero que no se enciende hasta que ha sido usado desde el lado del jefe. Estos atajos permiten un diseño que obliga al jugador a recorrer el nivel por el camino difícil la primera vez, pero que permiten saltarse grandes partes de él si el jugador vuelve en el futuro después de haberlo superado al menos una vez. También permiten un diseño de niveles lleno de pequeños caminos que se entreconectan y cruzan, creando arquitecturas donde las partes encajan como piezas de un reloj y que son muy satisfactorias de explorar.</p></description>
    </item>
    <item>
      <title>Juegos, tests y floats</title>
      <link>https://asielorz.github.io/posts/juegos-tests-floats</link>
      <guid>https://asielorz.github.io/posts/juegos-tests-floats</guid>
      <pubDate>Tue, 19 Jul 2022 00:00:00 +0000</pubDate>
      <description><p>Dice Kevlin Henney que, una vez superados los problemas culturales y entendido que los tests son beneficiosos para un proyecto de software, hay dos principales factores que impiden escribir tests automáticos para un programa. El primero es no saber cuál es el comportamiento correcto. No saber con exactitud cómo debería comportarse el programa. Un test es una función que dado un estado del programa y unas transformaciones sobre ese estado, espera un resultado determinado. Si no somos capaces de concretar de qué forma las reglas de nuestro programa transforman su estado, no podemos escribir tests. El segundo es cuando no sabemos cómo comprobar que algo es correcto. Hay código para el que es muy difícil escribir tests. Por ejemplo código que interactúa con el exterior, código que depende de grandes cantidades de datos, heurísticas que calculan aproximaciones de otras funciones...</p></description>
    </item>
    <item>
      <title>La programación funcional mueve la complejidad hacia abajo en la call stack, la procedural hacia arriba</title>
      <link>https://asielorz.github.io/posts/complejidad-call-stack-procedural-funcional</link>
      <guid>https://asielorz.github.io/posts/complejidad-call-stack-procedural-funcional</guid>
      <pubDate>Tue, 5 Jul 2022 00:00:00 +0000</pubDate>
      <description><p>Un programa escrito en un estilo procedural es una sucesión de pasos que modifican el estado del programa y de la máquina en la que se ejecuta. Estos pasos se agrupan en subrutinas que recogen una colección de instrucciones que tiene sentido ejecutar juntas y les dan un nombre y una estructura. Por lo general, son estas subrutinas las que abstraen la complejidad de las operaciones. Si miramos su función <code>main</code> o equivalente, el punto más abajo en la call stack definible por el usuario, nos encontramos con una sucesión de llamadas a funciones que hacen el trabajo de verdad. Estas funciones suelen por lo general mutar estado en variables privadas de clases o en variables globales que no es accesible al usuario. Por lo tanto, podemos decir que la complejidad de un programa procedural está en lo alto de la call stack, en las funciones finales que hacen la interacción con objetos o con el entorno. La abstracción funciona mediante la encapsulación, que se encarga de que el estado no sea visible ni modificable para el usuario excepto mediante las operaciones permitidas.</p></description>
    </item>
    <item>
      <title>Cómo las herramientas que usamos acotan el espacio de los videojuegos que podemos hacer</title>
      <link>https://asielorz.github.io/posts/herramientas-acotan-espacio-videojuegos</link>
      <guid>https://asielorz.github.io/posts/herramientas-acotan-espacio-videojuegos</guid>
      <pubDate>Sat, 2 Jul 2022 00:00:00 +0000</pubDate>
      <description><p>Recientemente, dos amigos míos, ambos desarrolladores de videojuegos profesionales con experiencia en la industria, han empezado por separado y sin saber el uno del otro a programar un juego por turnos. De las conversaciones con ambos sobre cómo estaban estructurando el código y cómo planeaban organizar la arquitectura de partes del programa surge esta reflexión sobre cómo las herramientas que usamos dirigen y limitan nuestra capacidad para pensar en soluciones.</p></description>
    </item>
    <item>
      <title>¿Está HTML obsoleto?</title>
      <link>https://asielorz.github.io/posts/esta-html-obsoleto</link>
      <guid>https://asielorz.github.io/posts/esta-html-obsoleto</guid>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      <description><p>Hace ya más de 30 años desde que Tim Berners-Lee inventó la world wide web, y no sería una subestimación decir que ha cambiado un poco del diseño original en este tiempo. El diseño original de internet tenía como objetivo facilitar y agilizar el proceso de publicación de trabajos académicos a los científicos, y consistía en una red global de documentos identificables y accesibles desde cualquier ordenador. Para ello Berners-Lee inventó tres tecnologías clave. HTTP, el protocolo que permite a dos ordenadores intercambiar hipertexto; HTML, el formato de hipertexto en el cual se escribían los documentos, y las URLs, que permitían identificar y solicitar de forma uniforme cualquier documento remoto desde cualquier ordenador. La clave está en que aquellas primeras páginas web eran páginas en el sentido más estricto, eran documentos que mayormente contenían información. El principal propósito de HTML era poder aunar en un documento texto con formato, imágenes y sobre todo enlaces a otros documentos.</p></description>
    </item>
    <item>
      <title>El maná en League of Legends y el aprendizaje instintivo de mecánicas de juego</title>
      <link>https://asielorz.github.io/posts/mana-league-of-legends</link>
      <guid>https://asielorz.github.io/posts/mana-league-of-legends</guid>
      <pubDate>Thu, 5 May 2022 00:00:00 +0000</pubDate>
      <description><p>El primer personaje que jugué de continuo en <i>League of Legends</i>, allá por 2013, fue Katarina. Había jugado otros aquí y allá, personajes que estaban gratis esa semana o eran muy baratos, pero el primero por el que me decanté para jugar mucho fue ese. Tengo el recuerdo de hojear la lista de personajes, entrando en los que me llamaran la atención, y sentirme muy atraído hacia la idea de que las habilidades de Katarina no tenían coste de maná. Todas eran gratis. Por aquel entonces el juego se me hacía excesivamente complejo y abrumador, demasiadas cosas a tener en la cabeza al mismo tiempo, y un personaje que me permitiera liberar algo de espacio mental sonaba muy prometedor.</p></description>
    </item>
    <item>
      <title>Plataformas y monopolios</title>
      <link>https://asielorz.github.io/posts/plataformas-y-monopolios</link>
      <guid>https://asielorz.github.io/posts/plataformas-y-monopolios</guid>
      <pubDate>Tue, 5 Apr 2022 00:00:00 +0000</pubDate>
      <description><p>El nacimiento del cine en Estados Unidos fue convulso. Edison, que había inventado el primer cinematógrafo a ese lado del charco, el quinetoscopio, que fue pionero en varios aspectos que luego se convertirían en estándares de la industria como el uso de cinta de celuloide de 35mm, patentó todos sus inventos relacionados con el cine y formó junto con los otros grandes productores de cine la Motion Pictures Patents Company, una organización que tenía como objetivo la monopolización de la producción cinematográfica y la persecución legal de los productores de cine que no pagaran una cuota a la entidad, usando la ley de patentes para cancelar sus producciones y someterlos a multas. Entre otras medidas, Eastman Kodak, parte del grupo y único fabricante de celuloide gracias a una patente, aceptó vender sólo a productores que formaran parte del acuerdo. También impuso restricciones a los intentos de empresas de otros países de hacer negocio en los Estados Unidos, llegando a conseguir que se prohibiera la entrada en el país de un representante de la empresa de los hermanos Lumière. Como curiosidad, la principal razón por la que los independientes terminaron asentándose en la ciudad de Los Ángeles, además de por el buen tiempo y la gran variedad de localidades de exteriores, era la distancia que los separaba de Nueva York y la proximidad de la frontera con México, por si tocaba salir por patas ante la llegada de los abogados del mago de Menlo Park. Al final el oligopolio fue llevado a juicio por William Fox, y su actividad sería considerada ilegal en 1915 por violar la ley Sherman anti-oligopolios de 1890.</p></description>
    </item>
    <item>
      <title>Elden Ring y dejarse unas funciones de debug</title>
      <link>https://asielorz.github.io/posts/elden-ring-funciones-debug</link>
      <guid>https://asielorz.github.io/posts/elden-ring-funciones-debug</guid>
      <pubDate>Fri, 1 Apr 2022 00:00:00 +0000</pubDate>
      <description><p>El otro día me llegó un vídeo de <i>Elden Ring</i> que explicaba cómo funcionan las colisiones del juego con respecto al combate mientras el jugador está saltando. Una cosa me llamó la atención de ese vídeo. La información había sido obtenida gracias a unas funciones de debug que los desarrolladores se habían dejado en el ejecutable y que permitía visualizar las cápsulas de colisión de los distintos personajes. Mi primera reacción fue de mofa. ¿Qué pasa? ¿Que hacer <code>#if DEBUG</code> no era una opción? ¿Qué es esto de dejarse funciones de debug en el ejecutable final? Pero, pensándolo mejor, creo que la cosa tiene más chicha, así que vamos a darle otra vuelta.</p></description>
    </item>
    <item>
      <title>Un óptimo local peligroso</title>
      <link>https://asielorz.github.io/posts/un-optimo-local-peligroso</link>
      <guid>https://asielorz.github.io/posts/un-optimo-local-peligroso</guid>
      <pubDate>Fri, 25 Feb 2022 00:00:00 +0000</pubDate>
      <description><p>Hay una tendencia en el desarrollo de software que lleva años cristalizando en el desarrollo de software, la de hacer que un programa dependa en gran medida de una única biblioteca enorme que tiene como objetivo cubrir la mayor parte de necesidades del programa. A falta de un término mejor, las llamaremos plataformas por usar el término que usa Roc. <i>Framework</i> también es un término común para describir a este tipo de bibliotecas. Hablamos de Unreal y Unity, de React y Angular, de Qt, de Ruby on rails y Node.js, por poner unos pocos ejemplos. Por proximidad la mayor parte de ejemplos de este texto serán sobre Unreal, pero son extrapolables a cualquiera. Me gusta el término “plataforma” porque es cierto que a ojos del programador estas bibliotecas abstraen la plataforma real hasta tal punto que en la práctica operan como la plataforma siendo programada. El programa medio que usa Unreal es totalmente indisociable de Unreal, hasta el punto de que cada estructura de datos, clase y función de ese programa sin excepción en algún momento se entrelaza con código de Unreal.</p></description>
    </item>
    <item>
      <title>Inscryption es un buen juego de cartas</title>
      <link>https://asielorz.github.io/posts/inscryption-es-un-buen-juego-de-cartas</link>
      <guid>https://asielorz.github.io/posts/inscryption-es-un-buen-juego-de-cartas</guid>
      <pubDate>Sun, 6 Feb 2022 00:00:00 +0000</pubDate>
      <description><p>Tenía miedo, yendo a jugar un juego del creador de <i>Pony island</i>, de que <i>Inscryption</i> fuera a ser simplemente raro. Que el juego de cartas fuera a ser una excusa para la rareza. Un truco para que el jugador creyera que estaba jugando a las cartas y en vez de eso el juego va de otra cosa. Y, sin embargo, estoy gratamente sorprendido de haberme encontrado con que <i>Inscryption</i> es, al menos en su primera parte, un excelente roguelike de cartas en el que todos los fuegos artificiales con los que Daniel Mullins juega con las reglas del medio y con la cuarta pared son complementarios a un sólido núcleo mecánico.</p></description>
    </item>
    <item>
      <title>¿Por qué es C la lingua franca de la programación?</title>
      <link>https://asielorz.github.io/posts/c-lingua-franca-programacion</link>
      <guid>https://asielorz.github.io/posts/c-lingua-franca-programacion</guid>
      <pubDate>Tue, 1 Feb 2022 00:00:00 +0000</pubDate>
      <description><p>La comunicación entre lenguajes de programación es un problema difícil, y uno para el que todavía no existe una solución satisfactoria, y desde luego no una solución universal. Las bibliotecas se diseñan para un lenguaje de programación en concreto, y usarlas desde otros es difícil. Los problemas van desde los técnicos, llamar a código escrito en otro lenguaje de programación es difícil y a veces hasta imposible depende de cómo de compatibles sean dos lenguajes, a estilísticos. Las bibliotecas se diseñan para explotar las propiedades y costumbres de un lenguaje en concreto, que pueden no traducirse correctamente a otros. Trabajar con mónadas es fácil en Haskell, pero muy tedioso en Java. Tener pointers intrusivos en estructuras de datos es fácil en C++, pero un infierno en Rust. Podemos pensar ejemplos a cientos.</p></description>
    </item>
    <item>
      <title>Sobre las reuniones</title>
      <link>https://asielorz.github.io/posts/sobre-las-reuniones</link>
      <guid>https://asielorz.github.io/posts/sobre-las-reuniones</guid>
      <pubDate>Wed, 26 Jan 2022 00:00:00 +0000</pubDate>
      <description><p>El factor que más afecta al contenido de una reunión es quién organiza la reunión. Cuando uno empieza a trabajar, es frecuente pensar en las reuniones como espacios de tiempo en los que unas personas concretas se reúnen y hablan de lo que necesiten hablar. Esta concepción de las reuniones no se corresponde con la realidad. Una reunión se convoca con un objetivo. Una persona o grupo de personas organizan una reunión con el objetivo de obtener una información, compartir una información o discutir un tema para formar un consenso. Las personas invitadas y el tiempo de la reunión están subordinados al objetivo de la reunión. Esta preconcepción falsa posiblemente venga de no ser consciente de que las reuniones tienen un objetivo, porque las reuniones son algo que organizan otras personas y a las que uno asiste.</p></description>
    </item>
    <item>
      <title>Cómo Dead cells te enseña a jugar sin perder vida</title>
      <link>https://asielorz.github.io/posts/dead-cells-jugar-sin-perder-vida</link>
      <guid>https://asielorz.github.io/posts/dead-cells-jugar-sin-perder-vida</guid>
      <pubDate>Mon, 24 Jan 2022 00:00:00 +0000</pubDate>
      <description><p><i>Dead cells</i> no quiere que te pases el juego. Quiere que te lo pases sin perder vida. Sin recibir un solo golpe de los enemigos. Diferentes juegos que usan una barra de vida en el jugador como condición de derrota tienen distinta relación con la vida como recurso. En las últimas dos entregas de <i>Doom</i>, por ejemplo, la curación es tan abundante y el juego incita tanto al riesgo y a los remates cuerpo a cuerpo que la barra de vida en las peleas de ese juego está en constante fluctuación entre los golpes que el jugador puede recibir cuando se mete entre enemigos y la curación que obtiene por derrotarlos. Así, el objetivo es encontrar y crear oportunidades para un riesgo controlado y no cometer demasiados errores antes de recuperarse con la recompensa. Sucede algo parecido en <i>Bloodborne</i>, gracias a mecánicas como la de recuperar parte de la vida perdida al atacar justo después de recibir un golpe, o el hecho de que el juego deja llevar hasta veinte objetos curativos a la vez, e incluso conseguir más de los enemigos derrotados a lo largo del nivel. En <i>Hollow knight</i> la curación es también muy abundante, pero requiere al jugador usar un hechizo que tarda en canalizar para curarse, lo que hace que no pueda usarse tan a menudo en los combates y se espacie más en el tiempo, aumentando el periodo de tiempo durante el cual el jugador no puede cometer errores. <i>Dark souls</i> aumenta todavía más este periodo, permitiendo al jugador recuperar las curaciones solamente en las pocas hogueras que hay diseminadas por el mapa. Fuera de la hoguera, el jugador cuenta tan solo con su barra de vida y sus frascos de curación, que no podrá recuperar hasta la siguiente. De todas formas, aunque el juego es conocido por su dificultad, suele tener la amabilidad de plantarte una hoguera cerca de cada jefe y varias esparcidas por cada nivel. Como vemos, distintos formatos de suministrar curación al jugador implican distinta relación del jugador con su barra de vida.</p></description>
    </item>
    <item>
      <title>El algoritmo de salto en la cabeza de Super Mario</title>
      <link>https://asielorz.github.io/posts/algoritmo-salto-cabeza-mario</link>
      <guid>https://asielorz.github.io/posts/algoritmo-salto-cabeza-mario</guid>
      <pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate>
      <description><p>En este texto quiero explicar uno de mis algoritmos de implementación de gameplay favoritos, por su simplicidad y elegancia resolviendo un problema bastante difícil. El problema es el siguiente, en un juego de plataformas como Super Mario en el que al saltar sobre un enemigo éste muere, cuando sucede una colisión entre el jugador y un enemigo, ¿cómo decide el juego si lo que está sucediendo es que el jugador ha saltado sobre el enemigo o por el contrario ha chocado contra él y es el jugador el que tiene que morir? El nombre que le doy al algoritmo es inventado por mí. No sé si fueron los programadores de Nintendo los inventores de este algoritmo, y es posible que no todos los juegos de Mario la usen. Sin embargo, <i>Super Mario Land</i> para la Game Boy es el juego más antiguo del que tengo constancia que usa este algoritmo. Otro ejemplo de juego que lo usa es uno de los juegos de móvil de Nitrome, <i>Leap Day</i>.</p></description>
    </item>
    <item>
      <title>Programación procedural, orientación a objetos y dónde se pone la frontera de la interfaz</title>
      <link>https://asielorz.github.io/posts/procedural-orientado-objetos-frontera-interfaz</link>
      <guid>https://asielorz.github.io/posts/procedural-orientado-objetos-frontera-interfaz</guid>
      <pubDate>Tue, 14 Dec 2021 00:00:00 +0000</pubDate>
      <description><p>La definición que da Alan Kay de la orientación a objetos es muy bonita. Kay define la orientación a objetos como la recursión del concepto de ordenador. El diseñar los componentes de un programa como entes independientes con su propio estado y capacidad de computación que se comunican mediante mensajes, al igual que lo hacen varios ordenadores conectados en una red. Para Kay, la orientación a objetos consistiría en coger esta idea de los ordenadores conectados en una red y aplicarla recursivamente, implementando cada uno de los programas que esos ordenadores están ejecutando en términos de pequeños “ordenadores” independientes, llamados objetos, que se comunican mediante mensajes y donde cada uno de ellos está asimismo compuesto por una red de objetos más pequeños, hasta llegar a los primitivos del lenguaje. Creo que es importante recordar la filosofía de Kay sobre todo para aquellos para los que nuestra percepción de la orientación a objetos viene modulada por lenguajes como C++, Java o C#. Las funciones virtuales y los patrones de diseño de la gang of four son circunstanciales, la encapsulación y la comunicación mediante mensajes son la esencia. Según estos criterios, el modelo de actores de Erlang podría considerarse más orientado a objetos que mucho código escrito en Java. Como dijo el propio el propio Alan Kay, “cuando acuñé el término orientado a objetos no estaba pensando en C++”.</p></description>
    </item>
    <item>
      <title>¿Qué significa que un parámetro sea out?</title>
      <link>https://asielorz.github.io/posts/que-significa-parametro-out</link>
      <guid>https://asielorz.github.io/posts/que-significa-parametro-out</guid>
      <pubDate>Tue, 14 Dec 2021 00:00:00 +0000</pubDate>
      <description><p>Tradicionalmente, los lenguajes de programación tipados con variables mutables han escrito la idea de función que modifica su parámetro como función que coge un pointer o una referencia al tipo del parámetro. En C, una función que coge un <code>int</code> solamente quiere leerlo, mientras que una función que coge un <code>int*</code> quiere escribir a él. Esta forma de describir la mutabilidad de los parámetros es común, y nos la encontramos también en C++ y hasta en Rust y Zig. Lenguajes como C#, Java, Python o JavaScript consiguen esquivar la discusión pasando implícitamente todos los argumentos por pointer mutable. En lenguajes puramente funcionales como Haskell la anotación tampoco tiene sentido, pero por la razón contraria: si todo es inmutable el pasar por copia o por referencia es semánticamente idéntico y se vuelve tan sólo un detalle de implementación y no algo que haga falta hacer decidir cada vez al programador. Por acotar el contexto del debate, este texto se centrará en lenguajes tipados con variables mutables, donde los tipos por defecto se comportan como valores (no como referencias) y donde se puede especificar la mutabilidad de las variables y las referencias. Es decir, en el espacio de diseño de lenguajes como C, C++, Rust, D o Zig, por nombrar unos pocos.</p></description>
    </item>
    <item>
      <title>protected es mentira</title>
      <link>https://asielorz.github.io/posts/protected-es-mentira</link>
      <guid>https://asielorz.github.io/posts/protected-es-mentira</guid>
      <pubDate>Fri, 19 Nov 2021 00:00:00 +0000</pubDate>
      <description><blockquote><p>&quot;I work with very good programmers and I see a ton of happens-to-work and very little actually correct.&quot;</p></blockquote></description>
    </item>
    <item>
      <title>Boy erased y The miseducation of Cameron Post argumentan lo mismo pero a distintos niveles</title>
      <link>https://asielorz.github.io/posts/boy-erased-cameron-post</link>
      <guid>https://asielorz.github.io/posts/boy-erased-cameron-post</guid>
      <pubDate>Tue, 2 Nov 2021 00:00:00 +0000</pubDate>
      <description><p><i>Boy erased</i> (Joel Edgerton, 2018) y <i>The miseducation of Cameron Post</i> (Desiree Akhavan, 2018) a priori podrían parecer la misma película. Ambas se estrenaron el mismo año, tratan el tema de las pseudo-terapias para curar la homosexualidad y tienen un guion muy similar, en el que un adolescente es ingresado en una de estas terapias por su familia, donde evidentemente no logrará cambiar y terminará escapando de alguna forma. Ambas películas denuncian esta práctica, pero lo hacen de forma distinta, para un público distinto y con tesis que lejos de ser redundantes se complementan muy bien.</p></description>
    </item>
    <item>
      <title>Los datos en la programación de UI: modelo, estado y configuración</title>
      <link>https://asielorz.github.io/posts/datos-programacion-UI</link>
      <guid>https://asielorz.github.io/posts/datos-programacion-UI</guid>
      <pubDate>Tue, 12 Oct 2021 00:00:00 +0000</pubDate>
      <description><p>Las interfaces gráficas son uno de los campos de la programación en el que el código tiende más al desorden y la chapuza. Es un área cercana al diseño, y por lo tanto propensa a una definición difusa de los requerimientos y a cambios y añadidos de funcionalidad espontáneos. Tampoco ayuda que la mayoría de bibliotecas para programar interfaces gráficas tengan un diseño en el que priorizan claramente unos aspectos del desarrollo sobre otros, lo que hace que el programador tenga que compensar al lidiar con ellos, y esto resulta tedioso. Este texto explora la estructura y el significado detrás de los datos manipulados por el código de UI, y la forma en la que estos datos son manipulados por código de UI escrito para ser componible. Se estudian como ejemplo práctico las bibliotecas ImGui y Slate, que son dos buenas bibliotecas de UI que permiten escribir código de manera composicional, pero tienen prioridades totalmente opuestas.</p></description>
    </item>
    <item>
      <title>No me gusta defer</title>
      <link>https://asielorz.github.io/posts/no-me-gusta-defer</link>
      <guid>https://asielorz.github.io/posts/no-me-gusta-defer</guid>
      <pubDate>Sun, 3 Oct 2021 00:00:00 +0000</pubDate>
      <description><p>Suele haber una gran influencia mutua en las decisiones de diseño de los lenguajes de programación de bajo nivel, o &quot;de sistemas&quot;, como se les llama ahora. Cuando uno desarrolla una nueva idea suele ser explorada y adoptada por varios durante los próximos años y es frecuente encontrar elementos similares o idénticos en varios de los lenguajes. Esto se debe principalmente a que la limitación de garantizar un gran control sobre la velocidad de ejecución del programa acota muchísimo el espacio de diseño, lo que hace que en última instancia todos estos lenguajes estén explorando el mismo subconjunto del espacio de diseño. La seguridad de los recursos, es decir, el evitar fugas de memoria u otros recursos, siempre ha sido una preocupación muy grande para estos lenguajes de programación, sobre todo debido a que en C, el abuelo de todos, garantizar la seguridad de los recursos es un proceso manual y en el que es fácil meter la pata. C++ resuelve el problema mediante los destructores. Un tipo encapsula un recurso y gracias a su destructor, que se ejecuta cuando el tipo es destruido, garantiza que el recurso siempre va a ser devuelto cuando deje de ser necesario. Esta idea ha sido muy influyente y es la adoptada por D y Rust. Por otro lado, en los últimos años ha surgido una forma alternativa de garantizar la seguridad de recursos: <code>defer</code>. Ideada originalmente por Go¹, <code>defer</code> es la forma preferente en Zig de gestionar recursos² y se está trabajando en añadirla a C³. Jai, el lenguaje de Jonathan Blow, también rechaza los destructores y se decanta por <code>defer</code>. Hay además implementaciones muy interesantes en C disponibles hoy usando el preprocesador⁸. En su último paso por CppCast, JeanHeyd Meneide, editor del documento del estándar de ISO de C y colaborador del comité estándar de C++, argumentó a favor de introducir <code>defer</code> en C e incluso de su potencial en C++ como complemento de los destructores⁴, explicando cómo facilitaría programar en el estilo transaccional descrito por Alexandrescu en la cppcon de 2015⁵.</p></description>
    </item>
    <item>
      <title>Pinned vector: la solución perfecta a un problema muy concreto</title>
      <link>https://asielorz.github.io/posts/pinned-vector</link>
      <guid>https://asielorz.github.io/posts/pinned-vector</guid>
      <pubDate>Mon, 9 Aug 2021 00:00:00 +0000</pubDate>
      <description><p>Existen muchas estructuras de datos que representan secuencias. Desde arrays dinámicos y listas a estructuras más esotéricas como listas de arrays de tamaño constante o el “chained group allocation pattern” muy usado por la biblioteca PLF. La selección de una u otra estructura depende mayormente de los requerimientos de complejidad asintótica en las operaciones, estabilidad de referencias y contigüidad de memoria. En el hardware actual, tanto para secuencias pequeñas como para secuencias grandes en las que el tamaño es conocido de antemano, el array dinámico es con frecuencia la estructura de datos preferida. Sin embargo, para colecciones muy grandes en las que el tamaño es desconocido, usar un array dinámico plantea un problema importante. Por lo general los arrays dinámicos reservan más memoria de la que necesitan, y presentan una distinción entre tamaño, la cantidad de elementos que contienen, y capacidad, la máxima cantidad de elementos que pueden contener con la memoria de la que disponen actualmente. Cuando se intenta insertar en un array en el que no hay capacidad para más, se reserva un array nuevo, frecuentemente del doble de tamaño, se mueven todos los elementos del antiguo al nuevo y se libera el bloque de memoria antiguo. Como por lo general mover elementos es una operación barata, reubicar arrays de decenas o cientos de elementos no suele ser un problema. Sin embargo, esto no es tan cierto cuando hablamos de cientos de miles o de millones de elementos. Para estas situaciones es preferible usar una estructura de datos distinta que no requiera de reubicar cientos de miles de elementos.</p></description>
    </item>
    <item>
      <title>Cambiar la implementación de malloc posiblemente no optimice tu programa</title>
      <link>https://asielorz.github.io/posts/cambiar-malloc-no-optimiza</link>
      <guid>https://asielorz.github.io/posts/cambiar-malloc-no-optimiza</guid>
      <pubDate>Tue, 3 Aug 2021 00:00:00 +0000</pubDate>
      <description><p>Un mito bastante común que me he encontrado, incluso en programadores con bastante experiencia, es la idea de que se puede sustituir el malloc que trae por defecto la biblioteca estándar de C por uno &quot;mejor&quot; y optimizar el programa así. Es bastante común, cuando hay problemas de velocidad por un número excesivo de llamadas a malloc que alguien proponga reemplazarlo por otro, como si existiera otra implementación que mágicamente fuera a hacer el mismo trabajo, pero más rápido. A esto tampoco ha ayudado Google, y su famoso TCMalloc, una implementación casera especializada para los requerimientos particulares de los programas de Google en los data centers. A lo que nadie parece prestar atención es a los números que da Google. Si uno lee <i>Beyond malloc efficiency to fleet efficiency: a hugepage-aware memory allocator</i> (Hunter et al, 2021), lo que vemos es que un gran rediseño de TCMalloc, que implicó entre otras cosas cambiar la forma en la que pensaban en la velocidad de reserva de memoria y los parámetros que usaban para medirla, y que les llevó meses de prueba y error y de micro optimización de los parámetros para sus problemas particulares, reportó entre un 3 y un 6% de mejora en la velocidad de los programas, y menos de un 10% en la cantidad de memoria usada. Sin embargo, lo más común es que alguien se de cuenta de que tiene problemas de memoria cuando no está en el orden de magnitud correcto, no cuando nota que está un 5% por encima de lo que debería, y cabe tener en cuenta que en una situación así cambiar de implementación de malloc difícilmente traerá las mediciones a los números que uno espera.</p></description>
    </item>
    <item>
      <title>¿Es &quot;iterator&quot; el mejor nombre para el concepto que representa en C++?</title>
      <link>https://asielorz.github.io/posts/iterator-mejor-nombre</link>
      <guid>https://asielorz.github.io/posts/iterator-mejor-nombre</guid>
      <pubDate>Tue, 20 Jul 2021 00:00:00 +0000</pubDate>
      <description><p>La primera mención que puedo encontrar al término &quot;iterator&quot; con el significado con el que lo usa la biblioteca estándar de C++ hoy es en el paper de David Musser y Alexander Stepanov de 1993 <i>Algorithm-oriented libraries</i>. El concepto sin embargo no era nuevo. En el fundacional paper de Musser y Stepanov de 1988 <i>Generic programming</i> podemos encontrar una idea similar bajo el nombre de &quot;coordinate&quot;. Citando el paper:</p></description>
    </item>
    <item>
      <title>weak_ptr considered harmful</title>
      <link>https://asielorz.github.io/posts/weak-ptr-harmful</link>
      <guid>https://asielorz.github.io/posts/weak-ptr-harmful</guid>
      <pubDate>Fri, 16 Jul 2021 00:00:00 +0000</pubDate>
      <description><p>C++11 incluyó <code>std::shared_ptr</code>, un tipo de &quot;smart pointer&quot; que permite a varios puntos del programa compartir la propiedad de un objeto. <code>shared_ptr</code> es una clase bastante útil para resolver algunos problemas. Además de esto, C++11 incluye <code>std::weak_ptr</code>, un tipo de smart pointer que puede apuntar a un objeto gestionado por un <code>shared_ptr</code> sin ser dueño, de forma que no tiene poder sobre cuándo el objeto va a ser destruido pero puede acceder a él mientras siga vivo. <code>weak_ptr</code> tiene dos usos principalmente. Por un lado, sirve para romper ciclos de referencias en grafos donde los nodos están conectados por <code>shared_ptr</code>s. Por otro, sirve para modelar una situación en la que un objeto necesita saber cuándo otro es destruido, sin tener ningún control sobre cuándo sucede esta destrucción. La existencia de <code>weak_ptr</code> no es gratuita. Para poder funcionar, es necesario que el bloque de control del objeto gestionado lleve, además de la cuenta del número de <code>shared_ptr</code>s que apuntan al objeto, la cuenta del número de <code>weak_ptr</code>s, ya que cuando el último <code>shared_ptr</code> es destruido, hay que destruir el objeto, pero no el bloque de control. Sin embargo, este coste es más bien nimio y en absoluto la razón de ser de este texto. Los casos de uso de <code>weak_ptr</code>, los problemas que resuelve, en realidad son, fuera de un diseño extremadamente orientado a objetos, antipatrones donde <code>weak_ptr</code> es un parche bonito que evita tener que razonar sobre cómo refactorizar el problema. Los sitios donde un programa usa <code>weak_ptr</code>, incluso en sus usos más canónicos, aquellos para los que fue diseñado, nos pueden apuntar a partes del programa donde la estructura de datos, la posesión y los patrones de acceso están vagamente definidos y crean un exceso artificial de complejidad.</p></description>
    </item>
    <item>
      <title>Sekiro: la estética como feedback</title>
      <link>https://asielorz.github.io/posts/sekiro-estetica-feedback</link>
      <guid>https://asielorz.github.io/posts/sekiro-estetica-feedback</guid>
      <pubDate>Thu, 24 Jun 2021 00:00:00 +0000</pubDate>
      <image>https://asielorz.github.io/images/sekiro.png</image>
      <description><p>Los juegos de Hidetaka Miyazaki han tenido hasta ahora dos vertientes bastante separadas en cuanto a la capacidad de personalización que ofrecen al jugador en su forma de jugar. Mientras que los juegos de la saga <i>Dark Souls</i> con su variedad de clases, armas, armaduras, estadísticas y hechizos, ofrecen al jugador un amplio abanico de formas de jugar (una vez que éste ha interiorizado el opaco sistema de subida de niveles), <i>Bloodborne</i> y <i>Sekiro: Shadows die twice</i> tienen opiniones fuertes sobre cuál es la forma correcta de jugar al juego, acotan mucho las estrategias disponibles y penalizan duramente el no jugar como el juego opina que hay que jugar. Sin embargo, mientras que la forma correcta de jugar a <i>Bloodborne</i> es más bien intuitiva, simplemente esquiva los golpes y ataca cuando tengas un hueco, con pequeños detalles que el jugador va aprendiendo sobre la marcha, <i>Sekiro</i> se encuentra en la compleja encrucijada entre plantear un sistema de combate bastante único en el videojuego y requerir al jugador que lo domine para avanzar. Esto conlleva un dificilísimo problema de feedback: <i>Sekiro</i> necesita decirle al jugador de forma comprensible cuándo está jugando de la forma &quot;correcta&quot;.</p></description>
    </item>
    <item>
      <title>std::move, ¡qué movida!</title>
      <link>https://asielorz.github.io/posts/std-move-que-movida</link>
      <guid>https://asielorz.github.io/posts/std-move-que-movida</guid>
      <pubDate>Mon, 7 Jun 2021 00:00:00 +0000</pubDate>
      <description><p>La definición de mover un objeto en C++ ha sido motivo de polémica desde el principio. En parte es comprensible, este es un campo en el que C++ fue pionero, y la solución que se diseñó fue una que resolvía de forma bastante elegante problemas importantes que el lenguaje arrastraba desde siempre, lo cual es meritorio cuando no hay ninguna referencia en la que basarse y de cuyos errores aprender. Diez años después, y con otros lenguajes como Rust habiéndose subido al carro, el sistema empieza a dejar ver sus costuras, y se vuelve a hablar sobre qué significa y qué debería significar mover un objeto. Es especialmente provocador el paper p2345<sup>[1]</sup> de un favorito de esta casa, Sean Parent, que plantea una redefinición del mover especialmente problemática por ser incompatible con la especificación actual y con la forma en la que el concepto se entiendo ahora mismo, pero que resuelve los problemas más acuciantes.</p></description>
    </item>
    <item>
      <title>Copy-on-write no se compone muy bien</title>
      <link>https://asielorz.github.io/posts/copy-on-write</link>
      <guid>https://asielorz.github.io/posts/copy-on-write</guid>
      <pubDate>Thu, 6 May 2021 00:00:00 +0000</pubDate>
      <description><p>Copy-on-write es un patrón muy útil para optimizar copias y compartir memoria entre estructuras de datos muy parecidas sin comprometer la relación parte-todo de estas estructuras. Es decir, haciendo que el hecho de que parte de la estructura es compartida sea un detalle de implementación invisible y no una propiedad de la estructura. Esta es una propiedad similar a la que consiguen arquitecturas funcionales con las llamadas estructuras de datos persistentes, que explotan la inmutabilidad para poder compartir gran parte del contenido de contenedores casi idénticos. El concepto es simple. Se le añade al objeto un contador de referencias. Además, cada vez que se va a llevar a cabo una operación que va a mutar el objeto, se comprueba el contador de referencias, y si es mayor que uno, se crea una copia. Copy-on-write tiene además la ventaja, para lenguajes como C++, de poder hacerlo con una sintaxis más favorable al estilo procedural, además de ser relativamente fácil de implementar de forma genérica. Es decir, podemos definir un tipo <code>CopyOnWrite&amp;lt;T&amp;gt;</code> para todo tipo regular <code>T</code>, que es isomórfico con <code>T</code> e implementa esta optimización. Además, esta interfaz permite ahorrar operaciones costosas como reservas de memoria en situaciones en las que el objeto pertenece a una única referencia, que la contraparte funcional no puede evitar.</p></description>
    </item>
    <item>
      <title>La composición procedural</title>
      <link>https://asielorz.github.io/posts/la-composicion-procedural</link>
      <guid>https://asielorz.github.io/posts/la-composicion-procedural</guid>
      <pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate>
      <description><h2>Introducción</h2></description>
    </item>
    <item>
      <title>Si algo podemos aprender de la programación funcional es que nos falta vocabulario</title>
      <link>https://asielorz.github.io/posts/nos-falta-vocabulario</link>
      <guid>https://asielorz.github.io/posts/nos-falta-vocabulario</guid>
      <pubDate>Mon, 8 Feb 2021 00:00:00 +0000</pubDate>
      <description><iframe src="https://www.youtube.com/embed/_XT73wdYFPA" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="true" style="aspect-ratio: 16 / 9;"></iframe></description>
    </item>
    <item>
      <title>No raw loops, no raw pointers. Estilo y arquitectura</title>
      <link>https://asielorz.github.io/posts/no-raw-loops-no-raw-pointers</link>
      <guid>https://asielorz.github.io/posts/no-raw-loops-no-raw-pointers</guid>
      <pubDate>Sun, 7 Feb 2021 00:00:00 +0000</pubDate>
      <description><p>Una de las charlas de informática más famosas y referenciadas que hay, al menos en el mundillo de C++, es la charla de Sean Parent de 2013 titulada <i>C++ seasoning</i>. La charla es brillante y está llena de un conocimiento profundo sobre arquitectura de software que es perfectamente extrapolable fuera del lenguaje C++, fruto de los más de 20 años de experiencia de Parent, y cubre cuatro metas, expresadas de forma negativa, que según el presentador un proyecto debería intentar alcanzar. Siete años después de la charla, y siendo su legado bastante patente, resulta llamativo que la primera sección de la charla, la que cubre los algoritmos y la meta de “no raw loops”, haya calado mucho más profundamente que el resto, y me cuesta no preguntarme por qué.</p></description>
    </item>
    <item>
      <title>El uso expresionista de la importancia en el lenguaje cinematográfico</title>
      <link>https://asielorz.github.io/posts/uso-expresionista-importancia</link>
      <guid>https://asielorz.github.io/posts/uso-expresionista-importancia</guid>
      <pubDate>Mon, 25 Jan 2021 00:00:00 +0000</pubDate>
      <description><p>Al leer una imagen, no toda la información que contiene tiene la misma importancia. Elementos como la composición, el color o la profundidad de campo jerarquizan la información y definen qué es más o menos importante. Por lo general, lo que está en el centro es más importante que lo que está a los lados, lo que está cerca más que lo que está lejos, lo que contrasta más que lo que no y lo que está enfocado más que lo que está desenfocado. La dirección de miradas de los personajes y las líneas en la imagen también guían nuestra mirada y nos dicen a dónde mirar. Es importante tener en cuenta que esta importancia es puramente formal y por lo tanto independiente del contenido de la imagen. Esto permite a fotógrafos y cineastas jugar con la decisión de qué es importante en el plano. Observemos por ejemplo este plano de <i>Naissance des pieuvres</i> (Céline Sciamma, 2007):</p></description>
    </item>
    <item>
      <title>El diseño de Pokémon atenta contra su propia diversión</title>
      <link>https://asielorz.github.io/posts/diseno-pokemon-atenta-diversion</link>
      <guid>https://asielorz.github.io/posts/diseno-pokemon-atenta-diversion</guid>
      <pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate>
      <description><p>Este texto expande las ideas de <a href="/posts/la-belleza-de-no-saber-como-funciona-pokemon">La belleza de no saber cómo funciona Pokémon</a>, entrando más en especificidades del diseño, pero mantiene la tesis principal: que <i>Pokémon</i> son dos juegos en uno, un RPG de un solo jugador y un juego competitivo de estrategia por turnos, y que el tener que satisfacer las necesidades de diseño de uno es un lastre para el otro.</p></description>
    </item>
    <item>
      <title>En busca del cantamañanas</title>
      <link>https://asielorz.github.io/posts/en-busca-del-cantamananas</link>
      <guid>https://asielorz.github.io/posts/en-busca-del-cantamananas</guid>
      <pubDate>Fri, 11 Dec 2020 00:00:00 +0000</pubDate>
      <description><p><i>En busca del Óscar</i> (Octavio Guerra, 2018) es un documental sobre el crítico de cine argentino Óscar Peyrou, presidente de la Asociación Española de la Prensa Cinematográfica y delegado de la FIPRESCI en Madrid. La película sigue a Peyrou a través de varios festivales y otros acontecimientos relacionados con el cine y pone especial énfasis en el peculiar modo del crítico de escribir sobre cine. Y es que Óscar Peyrou lleva veinte años sin verse las películas sobre las que habla. En vez de eso, su método se basa en analizar el cartel, el título, el reparto y el resto de información que puede obtener sin tener que verse la película, y luego escribir a ciegas. Lo cierto es que no me vi el documental. Lo dejé a los veinte minutos. Si el cantamañanas éste puede escribir sobre las películas sin verlas, yo puedo no verme la suya. De todas formas, lo que vi me bastó para ver que Peyrou es un sin fundamento que se da aires de listo con tendencia a la filosofía barata cada vez que se le presenta la oportunidad.</p></description>
    </item>
    <item>
      <title>Deificar a los algoritmos nos puede llevar a la impunidad de los responsables de sus consecuencias</title>
      <link>https://asielorz.github.io/posts/deificar-algoritmos</link>
      <guid>https://asielorz.github.io/posts/deificar-algoritmos</guid>
      <pubDate>Fri, 11 Dec 2020 00:00:00 +0000</pubDate>
      <description><p>Últimamente se habla mucho de algoritmos. Que si los algoritmos rigen nuestras vidas, que si deciden lo que vemos y leemos, que si actúan como censores… Y aunque esto es en parte verdad, creo que la imagen que se tiene de la informática en el imaginario colectivo y la forma en la que se habla de ella en el debate público está adquiriendo unas tendencias muy poco sanas, y que un poco más de conocimiento no haría daño. No estoy diciendo que ahora todos tengamos que ser doctores en inteligencia artificial, pero estaría bien tener al menos una noción a nivel divulgativo de qué narices es un algoritmo, en lugar de ser un palabro mágico que se invoca para nombrar al mal. Y es que en el imaginario colectivo los algoritmos parecen dioses de Lovecraft, seres inmensos e inescrutables que con su arbitrariedad rigen nuestras vidas y aplastan a gente a su paso sin ser siquiera conscientes de su existencia. Esta noción, que desde luego puede ser atractiva para quien en un momento dado pueda verse en la kafkiana situación de luchar contra un gigante tecnológico, es en realidad victimizante y dañina para los afectados, pues aleja el foco de los verdaderos perpetradores del problema para depositar la culpa en una herramienta que no tiene consciencia ni responsabilidad. Hablando mal y pronto, estamos culpando a la pistola y no al asesino.</p></description>
    </item>
    <item>
      <title>El sistema de actividades de Play Station 5 hace que jugar a juegos de mundo abierto sea brutalmente eficiente y esto es distópico</title>
      <link>https://asielorz.github.io/posts/actividades-play-station</link>
      <guid>https://asielorz.github.io/posts/actividades-play-station</guid>
      <pubDate>Fri, 4 Dec 2020 00:00:00 +0000</pubDate>
      <description><p>Recientemente me ha llegado por el slack del trabajo <a href="https://www.vice.com/en/article/93wb8d/ps5s-activities-system-makes-playing-open-world-games-brutally-efficient">un artículo</a> sobre el sistema de actividades de Play Station 5. El redactor explica cómo el sistema, que lista todas las actividades disponibles en ese momento con su duración estimada y permite teletransportarse inmediatamente a ellas, cambió significativamente su forma de jugar a Spiderman, eliminando la planificación de rutas y reduciendo mucho la cantidad de tiempo invertida en moverse por la ciudad. Desde Sony argumentan que el objetivo de este sistema es reducir la fricción entre la inversión de tiempo necesaria para jugar a un juego de un solo jugador y la falta de tiempo debida a las vicisitudes del día a día de la vida adulta, dando a los jugadores una forma de saltar directamente a la acción y ofreciéndoles una estimación de las duraciones de las distintas actividades a su disposición. Con esto buscan que los jugadores no requieran de sesiones de juego largas para poder jugar a juegos de un solo jugador, sino hacer estos accesibles a gente que únicamente dispone de sesiones de juego cortas y alejadas en el tiempo. Aunque desde luego este es un buen propósito, es interesante preguntarse cómo este sistema cambiará a los juegos que se harán en el futuro, y si será para bien.</p></description>
    </item>
    <item>
      <title>No tienes una teoría, con suerte tienes una hipótesis</title>
      <link>https://asielorz.github.io/posts/no-tienes-una-teoria</link>
      <guid>https://asielorz.github.io/posts/no-tienes-una-teoria</guid>
      <pubDate>Tue, 1 Dec 2020 00:00:00 +0000</pubDate>
      <description><p>El método científico define una teoría como un sistema lógico-deductivo constituido por un conjunto de hipótesis comprobadas, un campo de aplicación (de lo que trata la teoría, el conjunto de cosas que explica) y algunas reglas que permitan extraer consecuencias de las hipótesis, siendo una hipótesis un enunciado no verificado, una conjetura científica que requiere una contrastación con la experiencia. Últimamente, es cada vez más frecuente encontrarse justamente con el significado contrario. Cada vez es más común ver a gente usar la palabra “teoría” para designar una idea que por observación creen que puede ser verdad pero para la que no tienen pruebas, es decir, una hipótesis. Por lo general me parece de muy mal gusto lo de ir corrigiendo a la gente al hablar por eso de que <a href="https://starkeycomics.com/2019/04/18/linguistic-prescriptivists-make-terrible-zoologists/">los prescriptivistas lingüísticos son muy malos zoólogos</a>, pero creo que este fallo en concreto puede ser peligroso en una época en la que posturas anticientíficas como el terraplanismo, el creacionismo o el geocentrismo parece que empiezan a coger fuerza.</p></description>
    </item>
    <item>
      <title>Modo fácil de Dark Souls y capitalismo. Relación, si la hubiere.</title>
      <link>https://asielorz.github.io/posts/modo-facil-dark-souls-capitalismo</link>
      <guid>https://asielorz.github.io/posts/modo-facil-dark-souls-capitalismo</guid>
      <pubDate>Mon, 2 Nov 2020 00:00:00 +0000</pubDate>
      <description><p>Ante el relanzamiento para Play Station 5 de <i>Demon Souls</i> vuelve a surgir el eterno debate en torno a los juegos de Hidetaka Miyazaki de si deberían o no tener un modo fácil. Es ya la tercera vez (que yo recuerde) que veo el mismo tema siendo discutido, pues sucedió lo mismo con la salida de <i>Dark Souls 3</i> y <i>Sekiro</i>, y los argumentos y las posturas siguen siendo los mismos. Por eso, más interesante que el debate en sí, me parece la pregunta de por qué estamos discutiendo esto en primer lugar. ¿Qué es lo que lleva a toda esta gente a exigirle un modo fácil a unos desarrolladores que varias veces han declarado que no quieren ponerlo en su juego?</p></description>
    </item>
    <item>
      <title>NieR: Automata, la pluralidad del otro</title>
      <link>https://asielorz.github.io/posts/nier-automata-pluralidad-del-otro</link>
      <guid>https://asielorz.github.io/posts/nier-automata-pluralidad-del-otro</guid>
      <pubDate>Sat, 31 Oct 2020 00:00:00 +0000</pubDate>
      <description><p><i>NieR: Automata</i> comienza con una misión suicida en la que un grupo de androides se infiltran en una fábrica en la que las máquinas tienen guardada un arma peligrosa que debe ser destruida. Es una secuencia llena de acción y combates espectaculares, con momentos épicos y muertes dramáticas, pero sobre todo establece un marco de pensamiento inicial para el jugador. Androides buenos, máquinas malas. El juego lo hace claramente explícito mediante el personaje de 9S, que ayuda al jugador a lo largo de la misión y se encarga de recordarle que las máquinas no tienen sentimientos, tan sólo están programadas para seguir patrones simples. Y lo que vemos lo confirma. Todas las máquinas son enemigos, que al vernos ponen sus ojos en rojo y ejecutan ciclos simples de atacar y esperar como es común en cualquier enemigo de RPG. Tras esto, el juego nos da algo de contexto para lo que está sucediendo. Este juego sucede en una guerra entre humanos y aliens que se ha alargado durante siglos, en la que los humanos han sido expulsados de la Tierra y obligados a refugiarse en la Luna. Los humanos crearon a los androides para defenderse y los aliens a las máquinas. Nuestro deber como androides es combatir en la guerra y derrotar a las máquinas para que los humanos puedan volver a la tierra y recuperar la paz. Mediante esta primera misión y la cinemática explicativa que le sigue <i>NieR: Automata</i> logra establecer en el jugador un marco de pensamiento que será la base que luego dedicará el resto del juego a subvertir.</p></description>
    </item>
    <item>
      <title>&quot;Consumir contenido&quot;</title>
      <link>https://asielorz.github.io/posts/consumir-contenido</link>
      <guid>https://asielorz.github.io/posts/consumir-contenido</guid>
      <pubDate>Wed, 28 Oct 2020 00:00:00 +0000</pubDate>
      <description><p>Si hay dos palabras que se han convertido en ubicuas últimamente, hasta el punto de que han pasado a ser parte de nuestro vocabulario más o menos habitual y las decimos sin pensar, son “consumir” y “contenido”. De repente, todo es contenido. Ya venía siendo común referirse a la gente que difunde su trabajo principalmente por internet, gente del mundo de YouTube o que hace podcasts como “creadores de contenido”, pero es que últimamente vengo oyendo referirse como “contenido” incluso a series, películas y videojuegos. Parece que el contenido va abarcando más y más, expandiéndose y absorbiendo cada aspecto de nuestro ocio como la nada de la historia interminable.</p></description>
    </item>
    <item>
      <title>La (trágica) historia de amor LGBT</title>
      <link>https://asielorz.github.io/posts/tragica-historia-amor-lgbt</link>
      <guid>https://asielorz.github.io/posts/tragica-historia-amor-lgbt</guid>
      <pubDate>Wed, 21 Oct 2020 00:00:00 +0000</pubDate>
      <description><p>Cuando pienso en películas románticas LGBT, inevitablemente me vienen a la cabeza historias de amor trágicas en las que una relación muy breve pero intensa termina inevitablemente por presiones externas. Películas como <i>Brokeback mountain</i> (Ang Lee, 2005), <i>Call me by your name</i> (Luca Guadagnino, 2017) o <i>Retrato de una mujer en llamas</i> (Céline Sciamma, 2019) por nombrar un puñado. No debería extrañar a nadie que gente que es discriminada por su orientación sexual encuentre en el arquetipo de Romeo y Julieta la base perfecta para contar su experiencia en el amor, sobre todo al explorar las primeras veces y el estar en el armario. En palabras del director Mikel Rueda &quot;se han conseguido muchos logros, es verdad, pero todavía queda mucho por reclamar&quot;, y por eso es necesario este cine que muestra cómo la experiencia de algunos es innecesariamente mucho más dura que la del resto, por el nimio detalle de amar a alguien de su mismo género. La tragedia no sería entonces más que la sublimación de esta experiencia, que permite llevarla a la pantalla con la belleza con la que lo hacen las películas arriba mencionadas.</p></description>
    </item>
    <item>
      <title>Pequeña apología de las macros</title>
      <link>https://asielorz.github.io/posts/apologia-macros</link>
      <guid>https://asielorz.github.io/posts/apologia-macros</guid>
      <pubDate>Mon, 12 Oct 2020 00:00:00 +0000</pubDate>
      <description><p>No sorprenderé a nadie si digo que las macros de C son peligrosas. Ignoran completamente el sistema de tipos e incluso la sintaxis del lenguaje, pues suceden en un paso de preprocesador que se basa en un muy simple analizador léxico y consisten de sustitución textual. Es fácil introducir con ellas errores o ineficiencias sutiles que escapen a la vista pero que puedan explotar inesperadamente en el momento más inoportuno. El problema principal que resolvían en C, el código genérico, está ampliamente resuelto en C++ mediante las templates, que lo hacen además de una forma mucho más segura y expresiva. Sin embargo, sigue habiendo cosas que sólo las macros pueden hacer. Es más, conforme van metiendo más cosas a C++, el poder de las macros aumenta también de maneras a veces insospechadas. Y precisamente por estas cosas que sólo las macros pueden hacer yo creo que todavía hay un lugar para ellas en C++.</p></description>
    </item>
    <item>
      <title>De mónadas, corrutinas, &amp;lt;ranges&amp;gt; y programación funcional en C++</title>
      <link>https://asielorz.github.io/posts/monadas-corrutinas-ranges-funcional</link>
      <guid>https://asielorz.github.io/posts/monadas-corrutinas-ranges-funcional</guid>
      <pubDate>Mon, 12 Oct 2020 00:00:00 +0000</pubDate>
      <description><p>La programación funcional en C++ da bastante pereza. Se supone que el estilo en el que decidimos programar es aquel en el que seremos más productivos, cometeremos menos errores y podremos expresar mejor nuestra intención, ya que todos los programas pueden ser escritos en todos los paradigmas, y sin embargo cuando intentamos traer a C++ todo este asunto de las funciones de orden superior y mónadas que hemos aprendido de Haskell e intentamos componer nuestros programas a partir de ello nos encontramos teniendo que escribir demasiada paja que no está expresando intención ni haciéndonos más productivos, sino todo lo contrario. Y es que C++ no es Haskell, y cosas como fijar parámetros o crear funciones anónimas o de orden superior requiere mucho más tecleo, debido a la capacidad de C++ de expresar en detalle la forma del binario generado, capacidad que Haskell simplemente pasa por alto. Que C++ no sea Haskell también hace que la cultura sea diferente y por lo tanto que el código que ya hay escrito o que la forma en la que la gente escribe código sean diferentes. Pocas funciones cogen una cosa y devuelven otra, lo que hace que componer con el operador <code>bind</code> monádico sea más doloroso porque tenemos que recurrir a lambdas más veces que las que no. La gente que intenta que C++ sea Haskell, proponiendo añadir funciones de continuación a clases como <code>optional</code> o <code>future</code>, tal vez debería primero preguntarse si realmente es una forma viable de escribir código a gran escala. Es muy frustrante cuando en el intento de imitar los elegantes ejemplos de diapositiva de conferencia uno termina con unos churros ilegibles. La realidad es que, aunque el código de diapositiva puede permitirse ignorar los detalles, el código con el que uno lidia día a día está lleno de ellos, y es precisamente cuando entran en juego los detalles cuando el estilo funcional en C++ se vuelve más tedioso que útil.</p></description>
    </item>
    <item>
      <title>El disfrute de Showgirls no tiene por qué ser irónico</title>
      <link>https://asielorz.github.io/posts/showgirls-no-ironico</link>
      <guid>https://asielorz.github.io/posts/showgirls-no-ironico</guid>
      <pubDate>Wed, 30 Sep 2020 00:00:00 +0000</pubDate>
      <description><p>No sería exagerar decir que <i>Showgirls</i> (Paul Verhoeven, 1995) es una película polémica. No sólo por su uso del desnudo y su representación de los espectáculos que usan el cuerpo de la mujer para placer del público principalmente masculino, sino porque nadie parece ponerse de acuerdo en si la película es buena o mala, y por qué. <i>Showgirls</i> tuvo un estreno desastroso en el que fue destrozado por la crítica, escandalizó al público y no consiguió recuperar su abultado presupuesto de 40 millones de dólares. Hundió la carrera de Elizabeth Berkley, que venía de la televisión y esperaba con esta película lanzar su carrera de actriz en Hollywood. También ganó un puñado de premios Razzie, incluidos peor película y peor dirección. De hecho, Verhoeven se convirtió en la primera persona de la historia en recoger un Razzie en persona. Y es que es muy fácil sacarle peros a la película. Las actuaciones son exageradas y parodiables, y los momentos icónicos lo son más de la forma en la que lo es el “Oh, hi Mark” de <i>The room</i> (Tommy Wiseau, 2004) que el “Yo he visto cosas que vosotros no creeríais” de <i>Blade runner</i> (Ridley Scott, 1982). Los Ned Flanders del mundo pudieron disfrutar de un despliegue de desnudos de dos horas ante el que poner el grito en el cielo, mientras que la gente que iba buscando tetas se encontró con posiblemente una de las películas menos sexis que se han rodado. El trato del sexo en la película es muy incómodo, y todo lo relacionado con él es más grotesco que otra cosa. Es como si estuviera riéndose de esos espectadores poniéndoles un espejo delante.</p></description>
    </item>
    <item>
      <title>Los chistes de gitanos de Rober Bodegas y el buen humor negro</title>
      <link>https://asielorz.github.io/posts/rober-bodegas-gitanos-humor-negro</link>
      <guid>https://asielorz.github.io/posts/rober-bodegas-gitanos-humor-negro</guid>
      <pubDate>Tue, 29 Sep 2020 00:00:00 +0000</pubDate>
      <description><p>Hace unos años el cómico Rober Bodegas hizo un monólogo en el que hacía unos chistes sobre estereotipos hacia la comunidad gitana. Este monólogo fue rescatado años más tarde por una turba furibunda en twitter y le valió a Bodegas una persecución en redes sociales durante el par de semanas que duró aquello. Se acusaba al cómico de que sus chistes eran ofensivos hacia los gitanos. En este texto quiero diseccionar uno de esos chistes y ver por qué no sólo no es ofensivo hacia los gitanos, sino que ni siquiera va sobre gitanos. Es más, el chiste busca hablar sobre los prejuicios contra los gitanos.</p></description>
    </item>
    <item>
      <title>Anomalisa tiene que ser una película de animación</title>
      <link>https://asielorz.github.io/posts/anomalisa-tiene-que-ser-animacion</link>
      <guid>https://asielorz.github.io/posts/anomalisa-tiene-que-ser-animacion</guid>
      <pubDate>Sat, 26 Sep 2020 00:00:00 +0000</pubDate>
      <description><p>Ahora que con el lanzamiento de su última película, <i>I’m thinking of ending things</i>, Charlie Kaufman está en boca de muchos, me gustaría dejar por escrito una reflexión sobre otra de sus películas, <i>Anomalisa</i>. Es una película de animación en stop motion que usa para transmitir la idea de la obra un recurso que sólo sería posible para una película de animación.</p></description>
    </item>
    <item>
      <title>La belleza de no saber cómo funciona Pokémon</title>
      <link>https://asielorz.github.io/posts/la-belleza-de-no-saber-como-funciona-pokemon</link>
      <guid>https://asielorz.github.io/posts/la-belleza-de-no-saber-como-funciona-pokemon</guid>
      <pubDate>Tue, 22 Sep 2020 00:00:00 +0000</pubDate>
      <description><p>He jugado mucho a <i>Pokémon</i>. De niño metí una cantidad obscena de horas al <i>Esmeralda</i> y al <i>Perla</i>, además de pasarme también el <i>Verde hoja</i> de un amigo y gran parte del <i>Blanco</i> con mi primo. Ya en la carrera descubrí el mundo de los juegos hechos por fans, de los que he jugado un puñado y a los que también he dedicado más horas de las que me gustaría admitir. Sobre todo en <i>Reborn</i>, donde mi equipo está entrenado con naturaleza y EVs óptimos. Jugué OU competitivo en sexta generación y llegué a alcanzar un ELO bastante respetable, aunque no fuera estelar, en mi mejor momento. Lo que vengo a decir es que tengo un conocimiento bastante profundo de los sistemas de <i>Pokémon</i>. Sé cómo el juego calcula sus números, sé cómo se diseñan pokémon y equipos óptimos, y sé cómo se producen y se entrenan éstos para que lleguen a maximizar sus números. He dedicado tiempo a investigar y aprender estos sistemas y a poner en práctica mi conocimiento de ellos.  Y ahora, después de tanto esfuerzo, voy a revelarme contra todo ello.</p></description>
    </item>
    <item>
      <title>Toda clase que especialice las operaciones de mover debería ser construible por defecto</title>
      <link>https://asielorz.github.io/posts/operaciones-mover-constructor-por-defecto</link>
      <guid>https://asielorz.github.io/posts/operaciones-mover-constructor-por-defecto</guid>
      <pubDate>Mon, 21 Sep 2020 00:00:00 +0000</pubDate>
      <description><p>La idea detrás del diseño de RAII es que los recursos pertenecen a objetos. Un recurso es todo aquello que hay que pedir a un sistema y devolver cuando se deje de usar. Por supuesto el sistema operativo maneja recursos, como la memoria o los archivos, pero también puede ser algo más abstracto como el tiempo de uso de un mutex, e incluso podemos diseñar nuestros propios recursos que abstraigan y representen el comportamiento de nuestros sistemas. Un objeto puede adquirir recursos en su constructor o a lo largo de su vida, y debe liberarlos en el destructor. En RAII hay tres operaciones esenciales: el destructor, que tiene como función liberar los recursos; la copia, que crea un objeto cuyo valor observable es igual al de otro siendo ambos objetos separados e independientes; y mover, que transfiere los recursos de un objeto a otro, dejando al primero vacío. El estándar define que todo objeto del que se ha movido queda en un estado válido pero no especificado. En otras palabras, mover de un objeto no lo destruye, y un objeto del que se ha movido tiene que seguir pudiendo usarse. Por lo general un objeto del que se ha movido se queda en un estado vacío, en el que no es propietario de ningún recurso. Eso significa que para toda clase que implementa operaciones de movimiento, existe un estado válido en el que el objeto está vacío. Éste es también el estado en el que el destructor no hace nada, y es único. Para un tipo que implementa operaciones de movimiento, existe un solo estado en el que no es propietario de ningún recurso.</p></description>
    </item>
    <item>
      <title>Sobre XCOM, fallar rápido y la frustración</title>
      <link>https://asielorz.github.io/posts/XCOM-fallar-rapido-frustracion</link>
      <guid>https://asielorz.github.io/posts/XCOM-fallar-rapido-frustracion</guid>
      <pubDate>Tue, 15 Sep 2020 00:00:00 +0000</pubDate>
      <description><p>¿Alguna vez te has preguntado por qué, aunque <i>XCOM</i> tiene la estructura formal de un roguelike, no se juega ni se siente como tal? Este artículo explora por qué a los jugadores no les importa morir y volver a empezar una y otra vez en juegos como <i>The binding of Isaac</i>, <i>Spelunky</i> o <i>Dead cells</i> pero guardan compulsivamente tras cada turno y vuelen atrás ante cada error en <i>XCOM</i>.</p></description>
    </item>
    <item>
      <title>The Stanley parable, Firewatch, Florence: la interactividad sin desafío</title>
      <link>https://asielorz.github.io/posts/interactividad-sin-desafio</link>
      <guid>https://asielorz.github.io/posts/interactividad-sin-desafio</guid>
      <pubDate>Sat, 5 Sep 2020 00:00:00 +0000</pubDate>
      <description><p>El término <i>walking simulator</i>, antes de ser reapropiado con orgullo como el nombre de un género, fue un término despectivo que un sector de la crítica dio a unos juegos que desafiaron uno de los principios hasta entonces fundamentales del medio: la necesidad del desafío como eje vertebrador de la obra. En su origen, los walking simulators fueron vistos como poco interactivos o incluso no interactivos por un sector de los jugadores. De ahí el nombre: juegos que lo único que hacen es simular al jugador andando por un escenario. Sin embargo, los buenos walking simulators son esencialmente interactivos. No podrían ser si no fueran interactivos. La diferencia está en que lo son de formas distintas y con objetivos distintos al videojuego tradicional, y por eso se enfrentaron a esta incomprensión inicial.</p></description>
    </item>
    <item>
      <title>Reivindiquemos Los del túnel</title>
      <link>https://asielorz.github.io/posts/reivindiquemos-los-del-tunel</link>
      <guid>https://asielorz.github.io/posts/reivindiquemos-los-del-tunel</guid>
      <pubDate>Fri, 4 Sep 2020 00:00:00 +0000</pubDate>
      <description><p>No sé qué pasó con <i>Los del túnel</i> (Pepón Montero, 2017). Es una buena película, tenía dos caras conocidas dentro del panorama de la comedia en España (Arturo Valls en el papel protagonista y Raúl Cimas de antagonista), y cuando salió leí hablar bien de ella a nada menos que José Luis Cuerda, entre otros. Y sin embargo, la película no la vio casi nadie, no recuperó en taquilla su presupuesto y suspende con un cuatro y pico tanto en IMDb como en FilmAffinity. No he vuelto a oír hablar de ella, y me parece una lástima porque <i>Los del túnel</i> hace algo que se ve poco en el cine español, buen humor negro, de ese que mediante las hipocresías de sus personajes nos muestra miedos y actitudes nuestras que no sabíamos ni que teníamos, y que deformadas por el espejo cóncavo de Valle-Inclán nos arrancan carcajadas incómodas.</p></description>
    </item>
    <item>
      <title>Berlin Alexanderplatz y el cine de gangsters</title>
      <link>https://asielorz.github.io/posts/berlin-alexanderplatz-gangsters</link>
      <guid>https://asielorz.github.io/posts/berlin-alexanderplatz-gangsters</guid>
      <pubDate>Thu, 27 Aug 2020 00:00:00 +0000</pubDate>
      <description><p>Si, <a href="/posts/sin-perdon-y-lo-mitico/">como decíamos el otro día</a>, la conquista del Oeste es uno de los grandes mitos estadounidenses, narrando el proceso de llevar la civilización a todos los confines del país, su otro gran mito es el gangster, cara oscura de esa civilización. El crimen organizado surge en Estados Unidos sobre todo a raíz de la ley seca y se consolida durante la gran depresión. El cine de gangsters nace más o menos a la par, con Howard Hawks haciendo <i>Scarface</i> en 1932 sobre la vida del recién encarcelado Al Capone. Desde sus orígenes el cine de gangsters ha tenido vocación de alarma de la sociedad, pitando cuando las cosas no van del todo bien. En lo formal, se ha basado por lo general en los mitos de Fausto, el hombre que pacta con el diablo venderle su alma a cambio del poder terrenal, y de Macbeth, la ambición desmedida que lleva a la traición y a la muerte. Por lo general se trata de historias de ascenso y caída, con un personaje que empieza de cero, entra en el crimen organizado y asciende hasta lo más alto, donde será derribado por la ley, las bandas rivales y las luchas intestinas. También se han dado representaciones más naturalistas del crimen organizado, más alejadas de la visión mítica, en obras como <i>Camellos</i> (Spike Lee, 1995) o la serie <i>The Wire</i> (David Simon, 2002-2008), que se basan más en su impacto destructivo sobre los escalones más bajos y más pobres de la jerarquía de la mafia que en el ascenso y la caída de los capos.</p></description>
    </item>
    <item>
      <title>Braid Anniversary Edition y la lógica perversa de la mejora tecnológica</title>
      <link>https://asielorz.github.io/posts/braid-aniversario-tecnologia</link>
      <guid>https://asielorz.github.io/posts/braid-aniversario-tecnologia</guid>
      <pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate>
      <description><p>Me he cruzado recientemente por youtube con el anuncio de la edición de aniversario de <i>Braid</i>, para la que han vuelto a pintar a mano todas las texturas del juego con el fin de hacerlo más parecido a un cuadro, con detalles que parecen pinceladas de acuarela. La apariencia visual de algunas zonas ha sido rediseñada para hacerlas más únicas y también han retocado las animaciones para hacerlas más fluidas. Hay 9 píxeles por cada píxel en el juego original, afirman. También han mejorado el sonido y la música para potenciar la atmosfera del juego. Y es que el juego original es de 2008, estamos en 2020 y ahora las pantallas tienen más píxeles, supongo. En el vídeo ponen imágenes del juego original y la nueva versión una al lado de la otra y la diferencia se nota.</p></description>
    </item>
    <item>
      <title>The Witness, nuevas formas de mirar</title>
      <link>https://asielorz.github.io/posts/the-witness-nuevas-formas-de-mirar</link>
      <guid>https://asielorz.github.io/posts/the-witness-nuevas-formas-de-mirar</guid>
      <pubDate>Tue, 25 Aug 2020 00:00:00 +0000</pubDate>
      <description><p><i>The Witness</i> es un juego de puzles diseñado por Jonathan Blow, que tiene uno de los diseños de puzles más únicos y sorprendentes que he tenido la oportunidad de jugar, además de una visión autoral consistente y coherentemente transmitida mediante las mecánicas y el diseño de la obra. En este texto quiero poner por escrito un par de las cosas que me parecen más destacables.</p></description>
    </item>
    <item>
      <title>Argumentos contra la progresión y la personalización en el videojuego</title>
      <link>https://asielorz.github.io/posts/argumentos-contra-progresion-personalizacion</link>
      <guid>https://asielorz.github.io/posts/argumentos-contra-progresion-personalizacion</guid>
      <pubDate>Thu, 20 Aug 2020 00:00:00 +0000</pubDate>
      <description><p>Desde los tiempos de dragones y mazmorras, los jugadores han tenido interés en un personaje que crece a lo largo de la partida, tanto en nivel de poder como en personalización hacia un estilo de juego propio que desarrolla el jugador de acuerdo con sus gustos. Estos elementos en su origen más de nicho se han ido colando en el videojuego convencional y de un tiempo a esta parte hemos podido ver cómo la mayor parte de los lanzamientos triple A contienen elementos de progresión y personalización. Aunque esto en principio no tiene por qué ser negativo, al igual que no vengo a defender que este tipo de mecánicas, a las que la comunidad suele referirse como “elementos de RPG”, son inherentemente malas, sí que es cierto que tienen algunos problemas de diseño que me gustaría repasar.</p></description>
    </item>
    <item>
      <title>Debería std::move ser especializable?</title>
      <link>https://asielorz.github.io/posts/deberia-std-move-ser-especializable</link>
      <guid>https://asielorz.github.io/posts/deberia-std-move-ser-especializable</guid>
      <pubDate>Tue, 18 Aug 2020 00:00:00 +0000</pubDate>
      <description><p>El diseño de iteradores de la STL permite a un tipo de iterador especializar cuál va a ser el tipo de referencia que va a usar, definiendo dentro el tipo miembro <code>reference</code>. Esto por lo general va a ser <code>make_reference_v&amp;lt;value_type&amp;gt;</code>, pero la posibilidad de especializarlo permite cosas como que <code>vector&amp;lt;bool&amp;gt;</code> use un solo bit por bool, y aun así pueda tener iteradores. Para esto define un tipo de referencia que semánticamente actúa como representante de un bit, mientras que sintácticamente actúa como una referencia a bool. Para esto, la STL implícitamente define el concepto de referencia a T como algo que es convertible a T, a lo que se le puede asignar un T y que tiene constructor de copia. Otro tipo de referencia interesante es el par o la tupla de referencias, que permite implementar una vista sobre varios contenedores separados como una sola estructura.</p></description>
    </item>
    <item>
      <title>Sin perdón y lo mítico</title>
      <link>https://asielorz.github.io/posts/sin-perdon-y-lo-mitico</link>
      <guid>https://asielorz.github.io/posts/sin-perdon-y-lo-mitico</guid>
      <pubDate>Tue, 18 Aug 2020 00:00:00 +0000</pubDate>
      <description><p>Todas las naciones han buscado en su pasado material con el que dotarse de una identidad nacional de carácter legendario. Lo hicieron ya los romanos en leyendas fundacionales como Rómulo y Remo o la Eneida. Los estados europeos durante el romanticismo construyeron su identidad nacional sobre sus leyendas medievales, ya sean Covadonga, Camelot, los Nibelungos o Roldán y Carlomagno. Estados Unidos se encontraba ante la peculiar tesitura de ser un país muy joven, y desde luego sin historia medieval, de forma que tenían poco sobre lo que construir ese pasado nacional legendario. Podrían haberlo hecho sobre su guerra de la independencia, como harían los países latinoamericanos elevando a leyenda la figura de Simón Bolívar, pero en vez de eso optaron por esa gran Eneida colectiva para llevar la civilización a los rincones más remotos de su inmenso territorio que fue la conquista del Oeste.</p></description>
    </item>
    <item>
      <title>Sobre los posits, el sistema métrico en Estados Unidos y el coste del cambio</title>
      <link>https://asielorz.github.io/posts/posits-sistema-metrico-coste-cambio</link>
      <guid>https://asielorz.github.io/posts/posits-sistema-metrico-coste-cambio</guid>
      <pubDate>Sat, 8 Aug 2020 00:00:00 +0000</pubDate>
      <description><p>En el año 2017 el doctor John Gustafson presentó en la universidad de Stanford su trabajo sobre los posits, representación binaria de los números reales alternativa al punto flotante IEEE 754 que es el estándar actual. Los detalles de esta representación son irrelevantes para este texto (para los interesados podéis encontrar aquí <a href="https://www.youtube.com/watch?v=aP0Y1uAA-2Y">la charla grabada en vídeo</a> y <a href="http://www.johngustafson.net/pdfs/BeatingFloatingPoint.pdf">el paper en el que está basada</a>). El caso es que el doctor Gustafson afirma que los números reales representados según su modelo pueden representar un intervalo mayor que IEEE 754 con la misma cantidad de bits, y además las operaciones son más precisas y requieren circuitos menos complejos y por lo tanto más pequeños, más baratos y más rápidos. Vamos, que son mejores en todo. Si esto es o no verdad está también fuera del alcance de este texto, así que de ahora en adelante asumiremos que los posits realmente son mejores que los floats en todo, porque no es de lo que hemos venido a hablar. La representación binaria de números reales es muy importante para muchos campos como la inteligencia artificial, el big data, los cálculos científicos o las simulaciones. En un videojuego, es con diferencia el tipo de dato más común. Están hasta en la sopa. Que de repente por arte de birlibirloque éstos se volvieran más pequeños, más precisos y más rápidos sería como maná del cielo para nosotros. Pero por lo que sea aún no los está usando nadie, y merece la pena reflexionar sobre las razones que pueden estar reteniendo este cambio tan importante y aparentemente gratuito.</p></description>
    </item>
    <item>
      <title>Sobre dar espadazos a cosas y otra vez Dark Souls</title>
      <link>https://asielorz.github.io/posts/dar-espadazos-a-cosas-dark-souls</link>
      <guid>https://asielorz.github.io/posts/dar-espadazos-a-cosas-dark-souls</guid>
      <pubDate>Wed, 5 Aug 2020 00:00:00 +0000</pubDate>
      <description><p>Una cosa que me llama mucho la atención de <i>Bloodborne</i> es que de alguna manera su combate, a pesar de ser muchísimo más rápido y de no tener escudos, se siente en esencia parecido al de <i>Dark Souls</i>. Y llevo mucho tiempo intentando poner en palabras cuál es esa esencia de <i>Dark Souls</i>, que de alguna forma sobrevive a que le quiten los que en apariencia parecen ser sus elementos principales, pero que es tan raro de encontrar en otros juegos. La respuesta a la que finalmente he llegado es que, por lo general, en un juego de dar espadazos a cosas la acción más importante y que el jugador lleva a cabo más a menudo es reaccionar, mientras que en <i>Dark Souls</i> (y <i>Bloodborne</i>) es planificar.</p></description>
    </item>
    <item>
      <title>¿Dónde está la escuela de Undertale?</title>
      <link>https://asielorz.github.io/posts/donde-esta-la-escuela-de-undertale</link>
      <guid>https://asielorz.github.io/posts/donde-esta-la-escuela-de-undertale</guid>
      <pubDate>Wed, 22 Jul 2020 00:00:00 +0000</pubDate>
      <description><p>En 2015, después de que <i>Undertale</i> nos dejara a todos flipando con su estética retro, su música pegadiza, su sentido del humor y su impugnación de la violencia, la crítica se deshizo en afirmaciones de que esta obra extraña, hecha por un solo tipo y que salió del underground un poco de milagro, era el mejor videojuego de la historia y que cambiaría para siempre el rostro del videojuego como arte. Pues bien, han pasado cinco años y la influencia de <i>Undertale</i> ha sido más bien escasa. Apenas existen obras que se hayan basado en ella para expandir sus ideas y ahora mismo la vemos más como una isla, una rareza en medio de una marea que va a todas luces en otra dirección. Y uno no puede sino preguntarse qué narices ha pasado aquí.</p></description>
    </item>
    <item>
      <title>Victoria y la glorificación del esfuerzo</title>
      <link>https://asielorz.github.io/posts/victoria-glorificacion-esfuerzo</link>
      <guid>https://asielorz.github.io/posts/victoria-glorificacion-esfuerzo</guid>
      <pubDate>Tue, 30 Jun 2020 00:00:00 +0000</pubDate>
      <description><p><i>Victoria</i> (Sebastian Schipper, 2015) es una película dificilísima de rodar. La película consiste de un solo plano secuencia de dos horas y cuarto, y está rodada en una sola toma, sin recurrir a trucos como los que usa Hitchcock en <i>La soga</i> o Sam Mendes en <i>1917</i>, aprovechando muy oportunos obstáculos que pasan por delante de la cámara para cortar sin que se note. El trabajo tanto de los actores como del operador de cámara es titánico, y tiene muchísimo mérito, sobre todo teniendo en cuenta la cantidad de cosas que podían salir mal con ese guion y que los habría llevado a volver a empezar.</p></description>
    </item>
    <item>
      <title>malloc es especial</title>
      <link>https://asielorz.github.io/posts/malloc-es-especial</link>
      <guid>https://asielorz.github.io/posts/malloc-es-especial</guid>
      <pubDate>Sun, 28 Jun 2020 00:00:00 +0000</pubDate>
      <description><p>La programación funcional es un estilo de programación que modela los cálculos como la evaluación de expresiones, a diferencia de la programación imperativa, donde los cálculos suceden a través de la ejecución de instrucciones que mutan el estado del programa. Una función típica en un lenguaje funcional no es un conjunto de instrucciones que se ejecutan juntas, es decir, una subrutina, sino una asociación de un conjunto de valores a otro valor. Para esto es necesario que una función no mute sus parámetros y tampoco lea o escriba a estado mutable global, o interactúe con el exterior accediendo al sistema de archivos o a la red. Llamaremos a este tipo de cambios efectos secundarios, y a las funciones que no causan efectos secundarios funciones puras.</p></description>
    </item>
    <item>
      <title>operator ? y el mal código autogenerado</title>
      <link>https://asielorz.github.io/posts/operator-pregunta-mal-codigo-autogenerado</link>
      <guid>https://asielorz.github.io/posts/operator-pregunta-mal-codigo-autogenerado</guid>
      <pubDate>Tue, 23 Jun 2020 00:00:00 +0000</pubDate>
      <description><p>Contaba Kevlin Henney en una charla que revisando código de otra persona se encontró con una clase en la que para cada variable privada de la clase había un par de funciones get y set que leían y escribían la variable respectivamente, a pesar de que esto no tenía ningún sentido porque esas variables tenían que mantener una serie de invariantes que se podían romper si se les escribía valores arbitrarios. Al preguntarle al autor del código en cuestión por qué lo había hecho, este le contestaba que su editor de texto tenía una opción muy cómoda de autogenerar estas funciones, así que era algo que él ya hacía por defecto cada vez que añadía una variable a una clase. Henney aprovecha esta anécdota para reflexionar sobre la generación procedural de mal código y la forma en la que las herramientas que usamos dan forma a nuestra forma de pensar, no siempre para nuestro bien.</p></description>
    </item>
    <item>
      <title>Por un puñado de dólares y la construcción del duelo final</title>
      <link>https://asielorz.github.io/posts/punado-dolares-duelo-final</link>
      <guid>https://asielorz.github.io/posts/punado-dolares-duelo-final</guid>
      <pubDate>Mon, 22 Jun 2020 00:00:00 +0000</pubDate>
      <description><p>De entre toda la filmografía de Leone, destaca mucho la forma en la que en <i>Por un puñado de dólares</i> todo lo que sucede en la película conduce a y aumenta la expectativa del duelo final. Esto se irá perdiendo en sus películas posteriores, más largas y con tramas más complejas, hasta el punto de completamente prescindir del duelo final en <i>Agáchate, maldito</i>. Por eso quiero hablar de la estructura perfecta de <i>Por un puñado de dólares</i> y su apoteósico duelo final.</p></description>
    </item>
    <item>
      <title>Sobre incentivar la exploración en juegos de mundo abierto y algoritmos para recorrer grafos</title>
      <link>https://asielorz.github.io/posts/incentivar-exploracion-algoritmos-grafos</link>
      <guid>https://asielorz.github.io/posts/incentivar-exploracion-algoritmos-grafos</guid>
      <pubDate>Wed, 17 Jun 2020 00:00:00 +0000</pubDate>
      <description><p>Es una operación relativamente común en el campo de los grafos visitar cada nodo una vez, empezando por un nodo de origen y visitando recursivamente cada adyacente. Por lo general hay dos algoritmos usados para esto, la búsqueda en profundidad (<i>depth-first search</i>) y la búsqueda en anchura (<i>breadth-first search</i>), que se diferencian en si usan una pila o una cola para guardar los siguientes nodos a visitar. La búsqueda en profundidad prioriza llegar cuanto antes a los límites del grafo. Elige un camino y lo sigue hasta el final, y repite este proceso hasta haber visitado todos los nodos. La búsqueda en anchura prioriza visitar antes los nodos cercanos al origen. Cada vez que se visita un nodo, se visitarán todos los adyacentes a ese nodo antes de proceder con los adyacentes de estos.</p></description>
    </item>
    <item>
      <title>El scripting visual va lento</title>
      <link>https://asielorz.github.io/posts/el-scripting-visual-va-lento</link>
      <guid>https://asielorz.github.io/posts/el-scripting-visual-va-lento</guid>
      <pubDate>Wed, 27 May 2020 00:00:00 +0000</pubDate>
      <description><p>El scripting visual es importante. Si alguien aún sigue pensando que esto de programar con cajitas es para niños, sólo tiene que mirar al hecho de que tanto Unreal como Unity tienen sistemas de scripting visual, y es conocido que muchos motores privados incorporan estas técnicas también. El scripting visual es importante porque conforme más de nuestras herramientas se vuelven programables, más gente que no necesariamente tiene un trasfondo en ingeniaría del software tiene que ser capaz de programar para poder explotar a fondo estas herramientas. Que artistas y diseñadores sean capaces de programar puede reducir mucho los tiempos de iteración y por lo tanto acelerar mucho la velocidad de producción de un proyecto. Sin embargo, la forma tradicional de programar, el texto, puede ser innecesariamente difícil o incluso impenetrable para algunas de estas personas, que sin embargo al tener una mentalidad muy visual pueden entender esto de programar con cajitas mucho más fácilmente.</p></description>
    </item>
    <item>
      <title>La imperfección de las obras innovadoras o mi Dark Souls favorito es Hollow Knight</title>
      <link>https://asielorz.github.io/posts/dark-souls-hollow-knight</link>
      <guid>https://asielorz.github.io/posts/dark-souls-hollow-knight</guid>
      <pubDate>Sun, 10 May 2020 00:00:00 +0000</pubDate>
      <description><p>Es innegable la influencia de <i>Dark Souls</i> en el videojuego posterior, desde la miríada de clones que intentaron capitalizar el éxito del título hasta los juegos que realmente han entendido la obra, han aprendido de ella y lo han aplicado. Conceptos como el de lore, introducidos por este, son ya parte del lenguaje del videojuego. <i>Dark Souls</i> es ya uno de esos hitos del videojuego que marcan un antes y un después, como lo pudieron ser <i>Super Mario Bros</i>, <i>Doom</i> o <i>Half Life</i>.</p></description>
    </item>
    <item>
      <title>Yo, Daniel Blake y los prejuicios</title>
      <link>https://asielorz.github.io/posts/yo-daniel-blake-prejuicios</link>
      <guid>https://asielorz.github.io/posts/yo-daniel-blake-prejuicios</guid>
      <pubDate>Sun, 3 May 2020 00:00:00 +0000</pubDate>
      <description><p><i>Yo, Daniel Blake</i> cuenta la historia de un hombre que tras sufrir un infarto no puede trabajar por orden del médico, pero al que por una negligencia no le conceden la prestación por incapacidad. Para no quedarse sin ningún ingreso, solicita la prestación por desempleo, la cual le requiere buscar activamente trabajo para poder seguir recibiéndola. Entonces sucede esta escena.</p></description>
    </item>
    <item>
      <title>Hacia un sistema de memoria escalable y compatible con RAII</title>
      <link>https://asielorz.github.io/posts/sistema-memoria-escalable-RAII</link>
      <guid>https://asielorz.github.io/posts/sistema-memoria-escalable-RAII</guid>
      <pubDate>Sun, 26 Apr 2020 00:00:00 +0000</pubDate>
      <description><p>Reservar memoria, menuda movida. Es un problema tan difícil como importante, como se puede ver en el hecho de que la forma en la que se resuelve es un elemento bastante céntrico en el diseño de un lenguaje de programación, y hasta ahora se han dado muchas soluciones pero ninguna totalmente satisfactoria.</p></description>
    </item>
    <item>
      <title>Cómo Maybeshewill resignifica un discurso de Network</title>
      <link>https://asielorz.github.io/posts/network-maybeshewill</link>
      <guid>https://asielorz.github.io/posts/network-maybeshewill</guid>
      <pubDate>Tue, 21 Apr 2020 00:00:00 +0000</pubDate>
      <description><p><i>Network</i> (Sidney Lumet, 1976) narra la historia de una productora de televisión, interpretada por Faye Dunaway, que logra ascender en el mundo del audiovisual rescatando a un acabado presentador de informativos y convirtiéndolo en una especie de profeta loco. La película tiene algunos de los discursos más icónicos de la historia del cine que le valieron al actor que interpretaba al excéntrico presentador, Peter Finch, un bien merecido oscar. Es en el primero de estos discursos en el que me quiero centrar.</p></description>
    </item>
    <item>
      <title>std::lerp y por qué probablemente no quieras usarlo</title>
      <link>https://asielorz.github.io/posts/std-lerp</link>
      <guid>https://asielorz.github.io/posts/std-lerp</guid>
      <pubDate>Mon, 20 Apr 2020 00:00:00 +0000</pubDate>
      <description><p>C++20 introduce <code>std::lerp</code>, una función que dados tres números a, b y t, calcula la interpolación lineal entre a y b en t. Incluye overloads para todas las combinaciones de tipos numéricos en el lenguaje y hace lo que tiene que hacer. Es más, lo hace muy bien. Lo hace tan bien que para todo t entre 0 y 1 el resultado es <b>siempre</b> correcto.</p></description>
    </item>
    <item>
      <title>El habla en Frances Ha</title>
      <link>https://asielorz.github.io/posts/Frances-Ha-habla</link>
      <guid>https://asielorz.github.io/posts/Frances-Ha-habla</guid>
      <pubDate>Sat, 11 Apr 2020 00:00:00 +0000</pubDate>
      <description><p><i>Frances Ha</i> es una película maravillosa y hay muchas cosas que se podrían decir sobre ella, pero yo me quiero detener en un aspecto particular que me fascina: su uso del habla. Por lo general, el diálogo en el cine tiene como principal objetivo dar información al espectador sobre la trama, los personajes, el mundo... En <i>Frances Ha</i> el mundo es el Nueva York de hoy y la trama prácticamente inexistente, lo que libera al diálogo de gran parte de la carga expositiva porque no hay mucho que exponer, y la película en esta libertad puede permitirse usar el diálogo para explorar el habla. Porque una de las primeras cosas que chocan al verla es que los personajes no hablan &quot;como en las películas&quot;, hablan como personas. En este texto quiero explorar las dinámicas del habla cotidiana que <i>Frances Ha</i> refleja a la perfección y que son una rareza en gran parte del cine.</p></description>
    </item>
    <item>
      <title>Ori and the creep of the features</title>
      <link>https://asielorz.github.io/posts/Ori-and-the-creep-of-the-features</link>
      <guid>https://asielorz.github.io/posts/Ori-and-the-creep-of-the-features</guid>
      <pubDate>Wed, 1 Apr 2020 00:00:00 +0000</pubDate>
      <description><p><i>Ori and the blind forest</i> tiene uno de los mejores controles de jugador para un juego de plataformas 2D que se hayan hecho. Es simple, profundo y extremadamente satisfactorio. El juego está construido en torno a una mecánica a la que llama <i>bash</i>, que consiste en la habilidad de agarrarse durante el salto a enemigos o a elementos del nivel especialmente colocados para esto e impulsarse para saltar más lejos. El resto de mecánicas están diseñadas para interactuar con ello, como el doble salto, que se recarga cada vez que se usa el <i>bash</i> o la habilidad de planear que permite aguantar más en el aire para poder alcanzar ese apoyo que está un poco más lejos o, aún más interesante, dar tiempo a un enemigo a que cargue contra el jugador para apoyarse en él y salir impulsado hacia arriba. A todo esto el juego añade un mundo abierto que explorar con zonas secretas, un combate mediocre y un sistema de progresión y árbol de mejoras completamente innecesario que supongo que pretenderá justificar la exploración con coleccionables que desbloquean mejoras en este árbol.</p></description>
    </item>
    <item>
      <title>Celeste: Farewell y aprender de los speedrunners</title>
      <link>https://asielorz.github.io/posts/Celeste-speedrun</link>
      <guid>https://asielorz.github.io/posts/Celeste-speedrun</guid>
      <pubDate>Wed, 25 Mar 2020 00:00:00 +0000</pubDate>
      <description><p>Hace poco ha salido <i>Celeste: Farewell</i>, un DLC a Celeste que añade un nuevo mundo al final del juego, después del volcán, pensado para la gente que ya se ha pasado todo el juego. Tras unos cuantos niveles en los que se juega con una nueva mecánica, un paracaídas al que nos podemos agarrar para caer más despacio, se presenta la verdadera mecánica de la que va este mundo, el <i>wavedashing</i>.</p></description>
    </item>
  </channel>
</rss>
